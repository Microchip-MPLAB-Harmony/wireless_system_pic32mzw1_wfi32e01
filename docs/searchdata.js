var SearchFiles = ["GUID-653E183F-71C9-4BD2-9698-4D4BB2A2992A.html",
							"GUID-653E183F-71C9-4BD2-9698-4D4BB2A2992A.html",
							"GUID-653E183F-71C9-4BD2-9698-4D4BB2A2992A.html",
							"GUID-172B28B0-8A47-4C93-8023-8886A08BCD06.html",
							"GUID-A4D437CC-705D-469F-BBD6-8BF8C1B8E9FD.html",
							"GUID-A4D437CC-705D-469F-BBD6-8BF8C1B8E9FD.html",
							"GUID-A4D437CC-705D-469F-BBD6-8BF8C1B8E9FD.html",
							"GUID-35EAAD3C-3DC0-4AC0-8ECD-BD900AD22695.html",
							"GUID-578A7A2F-0FFE-463F-A241-3190441F74E0.html",
							"GUID-578A7A2F-0FFE-463F-A241-3190441F74E0.html",
							"GUID-578A7A2F-0FFE-463F-A241-3190441F74E0.html",
							"GUID-578A7A2F-0FFE-463F-A241-3190441F74E0.html",
							"GUID-39F92DDD-F7E2-45D1-B015-BF0B3A9FD6BD.html",
							"GUID-39F92DDD-F7E2-45D1-B015-BF0B3A9FD6BD.html",
							"GUID-39F92DDD-F7E2-45D1-B015-BF0B3A9FD6BD.html",
							"GUID-39F92DDD-F7E2-45D1-B015-BF0B3A9FD6BD.html",
							"GUID-A20F7777-F80F-4FC9-BC45-F39030A65105.html",
							"GUID-A20F7777-F80F-4FC9-BC45-F39030A65105.html",
							"GUID-A20F7777-F80F-4FC9-BC45-F39030A65105.html",
							"GUID-A20F7777-F80F-4FC9-BC45-F39030A65105.html",
							"GUID-68AB743B-D2CB-4548-86FD-10BB3E1C3FA6.html",
							"GUID-68AB743B-D2CB-4548-86FD-10BB3E1C3FA6.html",
							"GUID-68AB743B-D2CB-4548-86FD-10BB3E1C3FA6.html",
							"GUID-68AB743B-D2CB-4548-86FD-10BB3E1C3FA6.html",
							"GUID-57E25DE7-ED25-4DE8-9A44-C0BF175E752D.html",
							"GUID-57E25DE7-ED25-4DE8-9A44-C0BF175E752D.html",
							"GUID-57E25DE7-ED25-4DE8-9A44-C0BF175E752D.html",
							"GUID-57E25DE7-ED25-4DE8-9A44-C0BF175E752D.html",
							"GUID-F21D1BCE-BDCB-421D-B9E2-11B883C2AC54.html",
							"GUID-F21D1BCE-BDCB-421D-B9E2-11B883C2AC54.html",
							"GUID-F21D1BCE-BDCB-421D-B9E2-11B883C2AC54.html",
							"GUID-F21D1BCE-BDCB-421D-B9E2-11B883C2AC54.html",
							"GUID-9B772857-AD63-4637-BA65-C70530584A1E.html",
							"GUID-9B772857-AD63-4637-BA65-C70530584A1E.html",
							"GUID-9B772857-AD63-4637-BA65-C70530584A1E.html",
							"GUID-9B772857-AD63-4637-BA65-C70530584A1E.html",
							"GUID-FEC8454E-5F93-4596-800E-8B8BCBC24032.html",
							"GUID-FEC8454E-5F93-4596-800E-8B8BCBC24032.html",
							"GUID-FEC8454E-5F93-4596-800E-8B8BCBC24032.html",
							"GUID-FEC8454E-5F93-4596-800E-8B8BCBC24032.html",
							"GUID-38AED8C2-2FA2-4438-961E-79C3E153D01A.html",
							"GUID-38AED8C2-2FA2-4438-961E-79C3E153D01A.html",
							"GUID-38AED8C2-2FA2-4438-961E-79C3E153D01A.html",
							"GUID-38AED8C2-2FA2-4438-961E-79C3E153D01A.html",
							"GUID-F7EB79E2-9930-436C-BE86-720D58FE0BFB.html",
							"GUID-F7EB79E2-9930-436C-BE86-720D58FE0BFB.html",
							"GUID-F7EB79E2-9930-436C-BE86-720D58FE0BFB.html",
							"GUID-F7EB79E2-9930-436C-BE86-720D58FE0BFB.html",
							"GUID-F7EB79E2-9930-436C-BE86-720D58FE0BFB.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-4E47C21A-9803-41C3-853C-04FDAD30A075.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-988925A4-8993-491F-A8E9-8B7131FC0286.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-F457EE08-DC44-4FA8-952E-AE5EB673FF76.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-4A1F8FC6-6463-48BF-97C9-7BDFDCF686A6.html",
							"GUID-270923F2-A3D7-4B68-A399-AEAAFC7C0F64.html",
							"GUID-270923F2-A3D7-4B68-A399-AEAAFC7C0F64.html",
							"GUID-270923F2-A3D7-4B68-A399-AEAAFC7C0F64.html",
							"GUID-270923F2-A3D7-4B68-A399-AEAAFC7C0F64.html",
							"GUID-270923F2-A3D7-4B68-A399-AEAAFC7C0F64.html",
							"GUID-270923F2-A3D7-4B68-A399-AEAAFC7C0F64.html",
							"GUID-270923F2-A3D7-4B68-A399-AEAAFC7C0F64.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-11C5C134-0D1A-4812-9D5A-4F355264839C.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-53743705-6039-46B7-8052-7FB8438940F2.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-98A20067-8DD0-4FF2-846A-9EB8D1758ECE.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-3299B9CD-1B7F-47FD-95CD-636CC3BFFED6.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-00292779-019D-4DAF-B38F-317F529F725A.html",
							"GUID-6D4A7590-A5FE-418D-8A39-4F13DF7618BD.html",
							"GUID-0B818BAA-AF92-41F7-B4C1-7516ADA6F4A5.html",
							"GUID-0B818BAA-AF92-41F7-B4C1-7516ADA6F4A5.html",
							"GUID-0B818BAA-AF92-41F7-B4C1-7516ADA6F4A5.html",
							"GUID-0B818BAA-AF92-41F7-B4C1-7516ADA6F4A5.html",
							"GUID-0B818BAA-AF92-41F7-B4C1-7516ADA6F4A5.html",
							"GUID-226069A1-E832-4560-8457-6363E3A0EB83.html",
							"GUID-B5FCF623-E7FF-4626-AA04-20BCC3916E44.html",
							"GUID-B5FCF623-E7FF-4626-AA04-20BCC3916E44.html",
							"GUID-B5FCF623-E7FF-4626-AA04-20BCC3916E44.html",
							"GUID-B5FCF623-E7FF-4626-AA04-20BCC3916E44.html",
							"GUID-B5FCF623-E7FF-4626-AA04-20BCC3916E44.html",
							"GUID-B5FCF623-E7FF-4626-AA04-20BCC3916E44.html",
							"GUID-13E248BF-5C3E-4B90-A116-D708A72ECF13.html",
							"GUID-13E248BF-5C3E-4B90-A116-D708A72ECF13.html",
							"GUID-13E248BF-5C3E-4B90-A116-D708A72ECF13.html",
							"GUID-13E248BF-5C3E-4B90-A116-D708A72ECF13.html",
							"GUID-B8B066C9-9D43-45BF-B3E4-F0B4D07A496A.html",
							"GUID-B8B066C9-9D43-45BF-B3E4-F0B4D07A496A.html",
							"GUID-B8B066C9-9D43-45BF-B3E4-F0B4D07A496A.html",
							"GUID-B8B066C9-9D43-45BF-B3E4-F0B4D07A496A.html",
							"GUID-B2F4E27B-9331-4E16-9395-7B630DF98CC0.html",
							"GUID-B2F4E27B-9331-4E16-9395-7B630DF98CC0.html",
							"GUID-B2F4E27B-9331-4E16-9395-7B630DF98CC0.html",
							"GUID-B2F4E27B-9331-4E16-9395-7B630DF98CC0.html",
							"GUID-3E5312EC-F437-4001-870C-D02566138DE5.html",
							"GUID-3E5312EC-F437-4001-870C-D02566138DE5.html",
							"GUID-3E5312EC-F437-4001-870C-D02566138DE5.html",
							"GUID-3E5312EC-F437-4001-870C-D02566138DE5.html",
							"GUID-8C49DDF2-665A-4AE3-A68A-BBAE2C0A22DD.html",
							"GUID-8C49DDF2-665A-4AE3-A68A-BBAE2C0A22DD.html",
							"GUID-8C49DDF2-665A-4AE3-A68A-BBAE2C0A22DD.html",
							"GUID-8C49DDF2-665A-4AE3-A68A-BBAE2C0A22DD.html",
							"GUID-E9E4CB78-3ABF-44B7-BC07-9AD7EC142A9B.html",
							"GUID-E9E4CB78-3ABF-44B7-BC07-9AD7EC142A9B.html",
							"GUID-E9E4CB78-3ABF-44B7-BC07-9AD7EC142A9B.html",
							"GUID-E9E4CB78-3ABF-44B7-BC07-9AD7EC142A9B.html",
							"GUID-50083FB4-76EC-41B8-ADC6-A4466DE3972C.html",
							"GUID-50083FB4-76EC-41B8-ADC6-A4466DE3972C.html",
							"GUID-50083FB4-76EC-41B8-ADC6-A4466DE3972C.html",
							"GUID-50083FB4-76EC-41B8-ADC6-A4466DE3972C.html",
							"GUID-13A901DD-DEC5-4002-95DF-E87651A5FE82.html",
							"GUID-13A901DD-DEC5-4002-95DF-E87651A5FE82.html",
							"GUID-13A901DD-DEC5-4002-95DF-E87651A5FE82.html",
							"GUID-13A901DD-DEC5-4002-95DF-E87651A5FE82.html",
							"GUID-01230F94-41B8-4AF4-A81B-FFE243BAB213.html",
							"GUID-01230F94-41B8-4AF4-A81B-FFE243BAB213.html",
							"GUID-01230F94-41B8-4AF4-A81B-FFE243BAB213.html",
							"GUID-01230F94-41B8-4AF4-A81B-FFE243BAB213.html",
							"GUID-31D8837E-9521-4C37-820E-BC817E1A525D.html",
							"GUID-31D8837E-9521-4C37-820E-BC817E1A525D.html",
							"GUID-31D8837E-9521-4C37-820E-BC817E1A525D.html",
							"GUID-31D8837E-9521-4C37-820E-BC817E1A525D.html",
							"GUID-4756B92F-E53F-41CB-BA7F-2FDC1FBC85AC.html",
							"GUID-4756B92F-E53F-41CB-BA7F-2FDC1FBC85AC.html",
							"GUID-4756B92F-E53F-41CB-BA7F-2FDC1FBC85AC.html",
							"GUID-4756B92F-E53F-41CB-BA7F-2FDC1FBC85AC.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-28A59856-E897-40FA-B089-39C8C84D27CD.html",
							"GUID-C19B77FE-63FC-469F-A9C0-95D41B59DBE1.html",
							"GUID-C19B77FE-63FC-469F-A9C0-95D41B59DBE1.html",
							"GUID-C19B77FE-63FC-469F-A9C0-95D41B59DBE1.html",
							"GUID-C19B77FE-63FC-469F-A9C0-95D41B59DBE1.html",
							"GUID-C19B77FE-63FC-469F-A9C0-95D41B59DBE1.html",
							"GUID-C19B77FE-63FC-469F-A9C0-95D41B59DBE1.html",
							"GUID-31BDD8EE-0AB5-4542-BB67-A14746424248.html",
							"GUID-31BDD8EE-0AB5-4542-BB67-A14746424248.html",
							"GUID-31BDD8EE-0AB5-4542-BB67-A14746424248.html",
							"GUID-31BDD8EE-0AB5-4542-BB67-A14746424248.html",
							"GUID-31BDD8EE-0AB5-4542-BB67-A14746424248.html",
							"GUID-31BDD8EE-0AB5-4542-BB67-A14746424248.html",
							"GUID-31BDD8EE-0AB5-4542-BB67-A14746424248.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-4B38DADA-4E4A-4820-B0C5-6F4E3A99D44F.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-FF17C85E-72C4-4E0B-A7D5-A7B71C1DA84E.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-B0DCC36D-84BA-4AF0-8048-81D0E773F6BA.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-E459CCF2-499A-4FA1-8CD3-59A216415FD1.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-1FC1E3CD-9E78-4C97-ADD7-B04DBE255FC2.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-69ABE7A5-0098-4C34-B9AA-72DDB247C7F5.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-0785F012-1F1A-4AA4-9167-58736B812C00.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-114BB7C8-BE5C-46B0-84F4-6A459FC0A9A7.html",
							"GUID-F15AF9B8-740F-41C4-BFC2-850D793F858B.html",
							"GUID-B8C3059F-624D-4C22-93D5-33243DA6CB4F.html",
							"GUID-7ADBD426-1396-4DF4-842A-EAD15395A69C.html",
							"GUID-7ADBD426-1396-4DF4-842A-EAD15395A69C.html",
							"GUID-7ADBD426-1396-4DF4-842A-EAD15395A69C.html",
							"GUID-7ADBD426-1396-4DF4-842A-EAD15395A69C.html",
							"GUID-7ADBD426-1396-4DF4-842A-EAD15395A69C.html",
							"GUID-010BB62D-452D-4B87-9F43-FDA5BF80F6AF.html",
							"GUID-010BB62D-452D-4B87-9F43-FDA5BF80F6AF.html",
							"GUID-010BB62D-452D-4B87-9F43-FDA5BF80F6AF.html",
							"GUID-010BB62D-452D-4B87-9F43-FDA5BF80F6AF.html",
							"GUID-010BB62D-452D-4B87-9F43-FDA5BF80F6AF.html",
							"GUID-010BB62D-452D-4B87-9F43-FDA5BF80F6AF.html",
							"GUID-9F5B3013-33E1-4917-920A-F0F8FD1D704E.html",
							"GUID-9F5B3013-33E1-4917-920A-F0F8FD1D704E.html",
							"GUID-9F5B3013-33E1-4917-920A-F0F8FD1D704E.html",
							"GUID-9F5B3013-33E1-4917-920A-F0F8FD1D704E.html",
							"GUID-AFAB4E7D-CACF-4851-B9F6-B963450DB193.html",
							"GUID-AFAB4E7D-CACF-4851-B9F6-B963450DB193.html",
							"GUID-AFAB4E7D-CACF-4851-B9F6-B963450DB193.html",
							"GUID-AFAB4E7D-CACF-4851-B9F6-B963450DB193.html",
							"GUID-E5040CD9-28E3-4862-8A70-81C548C31901.html",
							"GUID-E5040CD9-28E3-4862-8A70-81C548C31901.html",
							"GUID-E5040CD9-28E3-4862-8A70-81C548C31901.html",
							"GUID-E5040CD9-28E3-4862-8A70-81C548C31901.html",
							"GUID-CBCB9481-CA72-4E90-A4FE-6243DAB9057B.html",
							"GUID-CBCB9481-CA72-4E90-A4FE-6243DAB9057B.html",
							"GUID-CBCB9481-CA72-4E90-A4FE-6243DAB9057B.html",
							"GUID-CBCB9481-CA72-4E90-A4FE-6243DAB9057B.html",
							"GUID-E8248C48-3802-4362-A1F6-80CD79C20956.html",
							"GUID-E8248C48-3802-4362-A1F6-80CD79C20956.html",
							"GUID-E8248C48-3802-4362-A1F6-80CD79C20956.html",
							"GUID-E8248C48-3802-4362-A1F6-80CD79C20956.html",
							"GUID-34AA46D6-A6BB-459C-95C5-4D4C733D21AC.html",
							"GUID-34AA46D6-A6BB-459C-95C5-4D4C733D21AC.html",
							"GUID-34AA46D6-A6BB-459C-95C5-4D4C733D21AC.html",
							"GUID-34AA46D6-A6BB-459C-95C5-4D4C733D21AC.html",
							"GUID-560DA0FB-8CF0-4EAB-A5D4-7641AE5FFBF3.html",
							"GUID-560DA0FB-8CF0-4EAB-A5D4-7641AE5FFBF3.html",
							"GUID-560DA0FB-8CF0-4EAB-A5D4-7641AE5FFBF3.html",
							"GUID-560DA0FB-8CF0-4EAB-A5D4-7641AE5FFBF3.html",
							"GUID-87D2FD77-3A00-47BA-9CCD-8FB708F03EA4.html",
							"GUID-87D2FD77-3A00-47BA-9CCD-8FB708F03EA4.html",
							"GUID-87D2FD77-3A00-47BA-9CCD-8FB708F03EA4.html",
							"GUID-87D2FD77-3A00-47BA-9CCD-8FB708F03EA4.html",
							"GUID-BE525C46-F3B6-45A6-AFB0-BB23EFAB4208.html",
							"GUID-BE525C46-F3B6-45A6-AFB0-BB23EFAB4208.html",
							"GUID-BE525C46-F3B6-45A6-AFB0-BB23EFAB4208.html",
							"GUID-BE525C46-F3B6-45A6-AFB0-BB23EFAB4208.html",
							"GUID-7EA384CB-36B6-4064-AC58-CC582F611968.html",
							"GUID-7EA384CB-36B6-4064-AC58-CC582F611968.html",
							"GUID-7EA384CB-36B6-4064-AC58-CC582F611968.html",
							"GUID-7EA384CB-36B6-4064-AC58-CC582F611968.html",
							"GUID-21594EF4-8CE1-4BFA-B2C3-CA15EF80D761.html",
							"GUID-21594EF4-8CE1-4BFA-B2C3-CA15EF80D761.html",
							"GUID-21594EF4-8CE1-4BFA-B2C3-CA15EF80D761.html",
							"GUID-21594EF4-8CE1-4BFA-B2C3-CA15EF80D761.html",
							"GUID-D2624727-1BC0-4511-BB6C-35D027018A24.html",
							"GUID-D2624727-1BC0-4511-BB6C-35D027018A24.html",
							"GUID-D2624727-1BC0-4511-BB6C-35D027018A24.html",
							"GUID-D2624727-1BC0-4511-BB6C-35D027018A24.html",
							"GUID-2D68F47B-8E2E-4F12-B126-AB828481897D.html",
							"GUID-2D68F47B-8E2E-4F12-B126-AB828481897D.html",
							"GUID-2D68F47B-8E2E-4F12-B126-AB828481897D.html",
							"GUID-2D68F47B-8E2E-4F12-B126-AB828481897D.html",
							"GUID-D3EC049D-63E2-4FC1-8A1A-7A4323878851.html",
							"GUID-D3EC049D-63E2-4FC1-8A1A-7A4323878851.html",
							"GUID-D3EC049D-63E2-4FC1-8A1A-7A4323878851.html",
							"GUID-D3EC049D-63E2-4FC1-8A1A-7A4323878851.html",
							"GUID-26537238-7459-436C-88BF-A506A0EC46B0.html",
							"GUID-26537238-7459-436C-88BF-A506A0EC46B0.html",
							"GUID-26537238-7459-436C-88BF-A506A0EC46B0.html",
							"GUID-26537238-7459-436C-88BF-A506A0EC46B0.html",
							"GUID-007A2A1C-CCE4-44C0-A735-2591D764708D.html",
							"GUID-007A2A1C-CCE4-44C0-A735-2591D764708D.html",
							"GUID-007A2A1C-CCE4-44C0-A735-2591D764708D.html",
							"GUID-007A2A1C-CCE4-44C0-A735-2591D764708D.html",
							"GUID-30A62A7C-8781-4779-A4F3-F1D5BC265D51.html",
							"GUID-30A62A7C-8781-4779-A4F3-F1D5BC265D51.html",
							"GUID-30A62A7C-8781-4779-A4F3-F1D5BC265D51.html",
							"GUID-30A62A7C-8781-4779-A4F3-F1D5BC265D51.html",
							"GUID-77D07DB9-DDA3-416C-B107-9B5789336162.html",
							"GUID-77D07DB9-DDA3-416C-B107-9B5789336162.html",
							"GUID-77D07DB9-DDA3-416C-B107-9B5789336162.html",
							"GUID-77D07DB9-DDA3-416C-B107-9B5789336162.html",
							"GUID-6D0974F9-BDE5-4905-BC62-CFA6733A675A.html",
							"GUID-6D0974F9-BDE5-4905-BC62-CFA6733A675A.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-95DB52B3-F70E-435B-96C6-96BB819004F7.html",
							"GUID-2C74519E-9B7A-45F9-B042-119754809978.html",
							"GUID-2C74519E-9B7A-45F9-B042-119754809978.html",
							"GUID-2C74519E-9B7A-45F9-B042-119754809978.html",
							"GUID-2C74519E-9B7A-45F9-B042-119754809978.html",
							"GUID-2C74519E-9B7A-45F9-B042-119754809978.html",
							"GUID-2C74519E-9B7A-45F9-B042-119754809978.html",
							"GUID-2C74519E-9B7A-45F9-B042-119754809978.html",
							"GUID-DF9EDA3A-3278-4F8C-9FF8-F392E49360DE.html",
							"GUID-DF9EDA3A-3278-4F8C-9FF8-F392E49360DE.html",
							"GUID-DF9EDA3A-3278-4F8C-9FF8-F392E49360DE.html",
							"GUID-DF9EDA3A-3278-4F8C-9FF8-F392E49360DE.html",
							"GUID-DF9EDA3A-3278-4F8C-9FF8-F392E49360DE.html",
							"GUID-DF9EDA3A-3278-4F8C-9FF8-F392E49360DE.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-1910387B-8C3A-4408-9D3D-7ABDC2A90E99.html",
							"GUID-9B0C8D64-9CC9-41EB-A114-321B1DECE901.html",
							"GUID-9B0C8D64-9CC9-41EB-A114-321B1DECE901.html",
							"GUID-9B0C8D64-9CC9-41EB-A114-321B1DECE901.html",
							"GUID-9B0C8D64-9CC9-41EB-A114-321B1DECE901.html",
							"GUID-9B0C8D64-9CC9-41EB-A114-321B1DECE901.html",
							"GUID-9B0C8D64-9CC9-41EB-A114-321B1DECE901.html",
							"GUID-9B0C8D64-9CC9-41EB-A114-321B1DECE901.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-16745EB6-5053-46F3-A8B2-3A1EEEB70BCA.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-2A33E6A9-B6CC-42BC-AD7D-EDE218C1AD45.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-20880B8D-6815-43DC-BCC6-8C29E1C1AE5A.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-CD8600B6-BDA0-4A35-AB3D-BF74C4540A2B.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-F55CC6FB-EF86-4353-9A2F-C56DD3EA2ED2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-335E6EC1-1976-4BDE-BC58-99C64AA570D2.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-5F93A938-03E8-4F80-BD6A-0BBC4B0D44F0.html",
							"GUID-6EA44F54-91D8-42F6-A226-793CA7D06695.html",
							"GUID-81C737BC-9E73-407C-ACAC-5B6795B77394.html",
							"GUID-81C737BC-9E73-407C-ACAC-5B6795B77394.html",
							"GUID-81C737BC-9E73-407C-ACAC-5B6795B77394.html",
							"GUID-B9CCAC68-A8F4-4EDA-85E0-729986577DA6.html",
							"GUID-B9CCAC68-A8F4-4EDA-85E0-729986577DA6.html",
							"GUID-B9CCAC68-A8F4-4EDA-85E0-729986577DA6.html",
							"GUID-B9CCAC68-A8F4-4EDA-85E0-729986577DA6.html",
							"GUID-B9CCAC68-A8F4-4EDA-85E0-729986577DA6.html",
							"GUID-B9CCAC68-A8F4-4EDA-85E0-729986577DA6.html",
							"GUID-B9CCAC68-A8F4-4EDA-85E0-729986577DA6.html",
							"GUID-B9C73D51-5039-4573-A452-176603C18703.html",
							"GUID-B9C73D51-5039-4573-A452-176603C18703.html",
							"GUID-B9C73D51-5039-4573-A452-176603C18703.html",
							"GUID-B9C73D51-5039-4573-A452-176603C18703.html",
							"GUID-B9C73D51-5039-4573-A452-176603C18703.html",
							"GUID-41A54E26-7261-45CA-AF4A-A0175CBE303E.html",
							"GUID-41A54E26-7261-45CA-AF4A-A0175CBE303E.html",
							"GUID-41A54E26-7261-45CA-AF4A-A0175CBE303E.html",
							"GUID-41A54E26-7261-45CA-AF4A-A0175CBE303E.html",
							"GUID-41A54E26-7261-45CA-AF4A-A0175CBE303E.html",
							"GUID-C7194E88-A1DC-4EFA-8FCE-B3127970E193.html",
							"GUID-C7194E88-A1DC-4EFA-8FCE-B3127970E193.html",
							"GUID-C7194E88-A1DC-4EFA-8FCE-B3127970E193.html",
							"GUID-C7194E88-A1DC-4EFA-8FCE-B3127970E193.html",
							"GUID-C7194E88-A1DC-4EFA-8FCE-B3127970E193.html",
							"GUID-5905E9EC-4C85-42AD-AC7C-90E41923D709.html",
							"GUID-5905E9EC-4C85-42AD-AC7C-90E41923D709.html",
							"GUID-5905E9EC-4C85-42AD-AC7C-90E41923D709.html",
							"GUID-5905E9EC-4C85-42AD-AC7C-90E41923D709.html",
							"GUID-5905E9EC-4C85-42AD-AC7C-90E41923D709.html",
							"GUID-3684FF88-AC4A-45AB-8857-49E1C46FDC61.html",
							"GUID-3684FF88-AC4A-45AB-8857-49E1C46FDC61.html",
							"GUID-3684FF88-AC4A-45AB-8857-49E1C46FDC61.html",
							"GUID-3684FF88-AC4A-45AB-8857-49E1C46FDC61.html",
							"GUID-3684FF88-AC4A-45AB-8857-49E1C46FDC61.html",
							"GUID-2BE63079-2FCD-4C89-9C2D-1ED1A506A66B.html",
							"GUID-2BE63079-2FCD-4C89-9C2D-1ED1A506A66B.html",
							"GUID-2BE63079-2FCD-4C89-9C2D-1ED1A506A66B.html",
							"GUID-2BE63079-2FCD-4C89-9C2D-1ED1A506A66B.html",
							"GUID-2BE63079-2FCD-4C89-9C2D-1ED1A506A66B.html",
							"GUID-B8650787-4731-48E9-B342-55EAFCC5496B.html",
							"GUID-B8650787-4731-48E9-B342-55EAFCC5496B.html",
							"GUID-B8650787-4731-48E9-B342-55EAFCC5496B.html",
							"GUID-B8650787-4731-48E9-B342-55EAFCC5496B.html",
							"GUID-B8650787-4731-48E9-B342-55EAFCC5496B.html",
							"GUID-BA16CF18-DCA0-4AA8-8A17-18EAC7380EF5.html",
							"GUID-BA16CF18-DCA0-4AA8-8A17-18EAC7380EF5.html",
							"GUID-BA16CF18-DCA0-4AA8-8A17-18EAC7380EF5.html",
							"GUID-BA16CF18-DCA0-4AA8-8A17-18EAC7380EF5.html",
							"GUID-BA16CF18-DCA0-4AA8-8A17-18EAC7380EF5.html",
							"GUID-BFAB8833-E678-457A-9C14-AEC9CA4B05B3.html",
							"GUID-BFAB8833-E678-457A-9C14-AEC9CA4B05B3.html",
							"GUID-BFAB8833-E678-457A-9C14-AEC9CA4B05B3.html",
							"GUID-BFAB8833-E678-457A-9C14-AEC9CA4B05B3.html",
							"GUID-BFAB8833-E678-457A-9C14-AEC9CA4B05B3.html",
							"GUID-1802D445-0432-4C05-83C5-8DF39FCC41DF.html",
							"GUID-1802D445-0432-4C05-83C5-8DF39FCC41DF.html",
							"GUID-1802D445-0432-4C05-83C5-8DF39FCC41DF.html",
							"GUID-1802D445-0432-4C05-83C5-8DF39FCC41DF.html",
							"GUID-1802D445-0432-4C05-83C5-8DF39FCC41DF.html",
							"GUID-3410AB90-8C90-4B2A-9A36-081663B2F794.html",
							"GUID-3410AB90-8C90-4B2A-9A36-081663B2F794.html",
							"GUID-3410AB90-8C90-4B2A-9A36-081663B2F794.html",
							"GUID-3410AB90-8C90-4B2A-9A36-081663B2F794.html",
							"GUID-3410AB90-8C90-4B2A-9A36-081663B2F794.html",
							"GUID-BE00844E-71BA-4BD6-BB06-7FFA362A0833.html",
							"GUID-BE00844E-71BA-4BD6-BB06-7FFA362A0833.html",
							"GUID-BE00844E-71BA-4BD6-BB06-7FFA362A0833.html",
							"GUID-BE00844E-71BA-4BD6-BB06-7FFA362A0833.html",
							"GUID-BE00844E-71BA-4BD6-BB06-7FFA362A0833.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-65C429E8-E63B-4FF1-8939-C80E558E0F29.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-86C7B809-3344-4813-95FE-24B5894EEC7C.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-17C14258-CDD3-4FBE-B2D5-528666AB0D33.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-F3CF23C1-1804-4A3D-AE91-4EDD8A565D37.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-6528061F-6F04-4A18-85C3-8B7839B8E235.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-61F4CED4-8E5E-421C-881E-A6BEAE2B392F.html",
							"GUID-C171D15D-DC5E-4D98-BD34-F95338A640A7.html",
							"GUID-C171D15D-DC5E-4D98-BD34-F95338A640A7.html",
							"GUID-C171D15D-DC5E-4D98-BD34-F95338A640A7.html",
							"GUID-C171D15D-DC5E-4D98-BD34-F95338A640A7.html",
							"GUID-C171D15D-DC5E-4D98-BD34-F95338A640A7.html",
							"GUID-6C1BB28E-7F9B-4582-8E74-E301F89C58AC.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-4913BE25-06C5-4ED7-9352-DA99287424F7.html",
							"GUID-7C9FB838-46C2-4CA1-A573-B110ED225368.html",
							"GUID-7C9FB838-46C2-4CA1-A573-B110ED225368.html",
							"GUID-EC779F2A-1DDD-4F5A-A648-47DE4498A25F.html",
							"GUID-EC779F2A-1DDD-4F5A-A648-47DE4498A25F.html",
							"GUID-EC779F2A-1DDD-4F5A-A648-47DE4498A25F.html",
							"GUID-EC779F2A-1DDD-4F5A-A648-47DE4498A25F.html",
							"GUID-EC779F2A-1DDD-4F5A-A648-47DE4498A25F.html",
							"GUID-3F684EBE-A5FB-4AE3-A0A8-629D54D9300B.html",
							"GUID-3F684EBE-A5FB-4AE3-A0A8-629D54D9300B.html",
							"GUID-3F684EBE-A5FB-4AE3-A0A8-629D54D9300B.html",
							"GUID-3F684EBE-A5FB-4AE3-A0A8-629D54D9300B.html",
							"GUID-3F684EBE-A5FB-4AE3-A0A8-629D54D9300B.html",
							"GUID-7FEA46C8-788C-4E6A-B46E-5A8FEE9B7CED.html",
							"GUID-7FEA46C8-788C-4E6A-B46E-5A8FEE9B7CED.html",
							"GUID-7FEA46C8-788C-4E6A-B46E-5A8FEE9B7CED.html",
							"GUID-7FEA46C8-788C-4E6A-B46E-5A8FEE9B7CED.html",
							"GUID-7FEA46C8-788C-4E6A-B46E-5A8FEE9B7CED.html",
							"GUID-2F0FEF24-2562-4783-A816-2E0B65C679D5.html",
							"GUID-2F0FEF24-2562-4783-A816-2E0B65C679D5.html",
							"GUID-2F0FEF24-2562-4783-A816-2E0B65C679D5.html",
							"GUID-2F0FEF24-2562-4783-A816-2E0B65C679D5.html",
							"GUID-2F0FEF24-2562-4783-A816-2E0B65C679D5.html",
							"GUID-BC6FF56F-269A-4570-B96A-76C3D29BF4D9.html",
							"GUID-BC6FF56F-269A-4570-B96A-76C3D29BF4D9.html",
							"GUID-BC6FF56F-269A-4570-B96A-76C3D29BF4D9.html",
							"GUID-BC6FF56F-269A-4570-B96A-76C3D29BF4D9.html",
							"GUID-BC6FF56F-269A-4570-B96A-76C3D29BF4D9.html",
							"GUID-4D8F8775-405D-4FE4-B72E-9807B7005C89.html",
							"GUID-4D8F8775-405D-4FE4-B72E-9807B7005C89.html",
							"GUID-4D8F8775-405D-4FE4-B72E-9807B7005C89.html",
							"GUID-4D8F8775-405D-4FE4-B72E-9807B7005C89.html",
							"GUID-4D8F8775-405D-4FE4-B72E-9807B7005C89.html",
							"GUID-445B119E-3EAD-4ECB-8662-27AB3B193F52.html",
							"GUID-445B119E-3EAD-4ECB-8662-27AB3B193F52.html",
							"GUID-445B119E-3EAD-4ECB-8662-27AB3B193F52.html",
							"GUID-445B119E-3EAD-4ECB-8662-27AB3B193F52.html",
							"GUID-445B119E-3EAD-4ECB-8662-27AB3B193F52.html",
							"GUID-791A8D39-45C6-4D33-A082-C308E48A6D7B.html",
							"GUID-791A8D39-45C6-4D33-A082-C308E48A6D7B.html",
							"GUID-791A8D39-45C6-4D33-A082-C308E48A6D7B.html",
							"GUID-791A8D39-45C6-4D33-A082-C308E48A6D7B.html",
							"GUID-791A8D39-45C6-4D33-A082-C308E48A6D7B.html",
							"GUID-F46FB0B5-D797-4A03-A691-D212DA77C376.html",
							"GUID-F46FB0B5-D797-4A03-A691-D212DA77C376.html",
							"GUID-F46FB0B5-D797-4A03-A691-D212DA77C376.html",
							"GUID-F46FB0B5-D797-4A03-A691-D212DA77C376.html",
							"GUID-F46FB0B5-D797-4A03-A691-D212DA77C376.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-BCF00564-E312-4462-A11B-079E6A5414EB.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-6FAB8216-E82D-4B1B-899B-55CC9B16302A.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-A3BBC2D0-94C5-4D00-8A54-558B7F27500F.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-244208E3-3A35-4EA4-8A25-08FB3A0C34F1.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-9015FCED-F411-41BE-B7DE-6929204283F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-2B3ABECA-845C-4A2C-90DA-6BB38A0424F6.html",
							"GUID-C691B5FA-0B04-4C7F-B71B-B7481D5BB75A.html",
							"GUID-C691B5FA-0B04-4C7F-B71B-B7481D5BB75A.html",
							"GUID-C691B5FA-0B04-4C7F-B71B-B7481D5BB75A.html",
							"GUID-AF87F0BB-E319-4436-A302-357BFA7E193E.html",
							"GUID-AF87F0BB-E319-4436-A302-357BFA7E193E.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-E13DC21B-3F94-455C-8DB3-48F8F7163844.html",
							"GUID-44230E49-6079-4901-9D7C-F71412C3B9EA.html",
							"GUID-44230E49-6079-4901-9D7C-F71412C3B9EA.html",
							"GUID-44230E49-6079-4901-9D7C-F71412C3B9EA.html",
							"GUID-F8A21576-2DFD-406F-9736-CEFDE7AD5207.html",
							"GUID-F8A21576-2DFD-406F-9736-CEFDE7AD5207.html",
							"GUID-F8A21576-2DFD-406F-9736-CEFDE7AD5207.html",
							"GUID-F8A21576-2DFD-406F-9736-CEFDE7AD5207.html",
							"GUID-F8A21576-2DFD-406F-9736-CEFDE7AD5207.html",
							"GUID-F03C9E56-6E27-4686-A0CA-14D14F615FB5.html",
							"GUID-F03C9E56-6E27-4686-A0CA-14D14F615FB5.html",
							"GUID-F03C9E56-6E27-4686-A0CA-14D14F615FB5.html",
							"GUID-F03C9E56-6E27-4686-A0CA-14D14F615FB5.html",
							"GUID-FF900B9E-1306-498E-8261-D7FEFA8CC184.html",
							"GUID-FF900B9E-1306-498E-8261-D7FEFA8CC184.html",
							"GUID-FF900B9E-1306-498E-8261-D7FEFA8CC184.html",
							"GUID-FF900B9E-1306-498E-8261-D7FEFA8CC184.html",
							"GUID-FF900B9E-1306-498E-8261-D7FEFA8CC184.html",
							"GUID-7E595932-B68F-4074-BA7D-36D836AA8B5B.html",
							"GUID-7E595932-B68F-4074-BA7D-36D836AA8B5B.html",
							"GUID-7E595932-B68F-4074-BA7D-36D836AA8B5B.html",
							"GUID-7E595932-B68F-4074-BA7D-36D836AA8B5B.html",
							"GUID-7E595932-B68F-4074-BA7D-36D836AA8B5B.html",
							"GUID-7B12B319-188D-4C1D-8AEE-349BE7660528.html",
							"GUID-7B12B319-188D-4C1D-8AEE-349BE7660528.html",
							"GUID-7B12B319-188D-4C1D-8AEE-349BE7660528.html",
							"GUID-7B12B319-188D-4C1D-8AEE-349BE7660528.html",
							"GUID-7B12B319-188D-4C1D-8AEE-349BE7660528.html",
							"GUID-6B52ABB2-B67F-4DC8-9147-43E43664223B.html",
							"GUID-6B52ABB2-B67F-4DC8-9147-43E43664223B.html",
							"GUID-6B52ABB2-B67F-4DC8-9147-43E43664223B.html",
							"GUID-6B52ABB2-B67F-4DC8-9147-43E43664223B.html",
							"GUID-E3DE3951-0B4D-44ED-8EDD-5DE48A3597FC.html",
							"GUID-E3DE3951-0B4D-44ED-8EDD-5DE48A3597FC.html",
							"GUID-E3DE3951-0B4D-44ED-8EDD-5DE48A3597FC.html",
							"GUID-E3DE3951-0B4D-44ED-8EDD-5DE48A3597FC.html",
							"GUID-E3DE3951-0B4D-44ED-8EDD-5DE48A3597FC.html",
							"GUID-793F497B-BD41-400B-9FB5-0C0ECBB2B1D5.html",
							"GUID-793F497B-BD41-400B-9FB5-0C0ECBB2B1D5.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-0B54E267-5E7C-4408-BB57-0BB6E61B59D3.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-8F2A596D-F14C-43E8-8D8C-951C45191D23.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-10DC0C0A-E5D5-417A-86E0-199C0ECC0B50.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-D861E940-4256-413D-ACFD-88DD118AFA93.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-C340E1A4-6E08-4399-8480-E07BA98EDFB2.html",
							"GUID-097A4209-8474-480E-A141-6C8FC60A7671.html",
							"GUID-3F1BB7CA-C728-4096-9386-35EC426BDD9F.html",
							"GUID-3F1BB7CA-C728-4096-9386-35EC426BDD9F.html",
							"GUID-3F1BB7CA-C728-4096-9386-35EC426BDD9F.html",
							"GUID-3F1BB7CA-C728-4096-9386-35EC426BDD9F.html",
							"GUID-3F1BB7CA-C728-4096-9386-35EC426BDD9F.html",
							"GUID-3F1BB7CA-C728-4096-9386-35EC426BDD9F.html",
							"GUID-F3104485-0F0B-4CB8-B1F6-88C6F8873471.html",
							"GUID-9DCBB817-ECC8-46C6-954B-F6B0D8F5C0BC.html",
							"GUID-9DCBB817-ECC8-46C6-954B-F6B0D8F5C0BC.html",
							"GUID-9DCBB817-ECC8-46C6-954B-F6B0D8F5C0BC.html",
							"GUID-9DCBB817-ECC8-46C6-954B-F6B0D8F5C0BC.html",
							"GUID-818A720C-1FD4-4EA4-B22C-F44B52F11DB5.html",
							"GUID-818A720C-1FD4-4EA4-B22C-F44B52F11DB5.html",
							"GUID-818A720C-1FD4-4EA4-B22C-F44B52F11DB5.html",
							"GUID-818A720C-1FD4-4EA4-B22C-F44B52F11DB5.html",
							"GUID-7A668B78-45FE-4EDF-965E-1900422374CE.html",
							"GUID-7A668B78-45FE-4EDF-965E-1900422374CE.html",
							"GUID-7A668B78-45FE-4EDF-965E-1900422374CE.html",
							"GUID-7A668B78-45FE-4EDF-965E-1900422374CE.html",
							"GUID-067B7E35-0233-4030-BDC7-ADA3C5A65281.html",
							"GUID-067B7E35-0233-4030-BDC7-ADA3C5A65281.html",
							"GUID-067B7E35-0233-4030-BDC7-ADA3C5A65281.html",
							"GUID-067B7E35-0233-4030-BDC7-ADA3C5A65281.html",
							"GUID-B12643ED-A0B9-4331-9E81-961355411485.html",
							"GUID-B12643ED-A0B9-4331-9E81-961355411485.html",
							"GUID-B12643ED-A0B9-4331-9E81-961355411485.html",
							"GUID-B12643ED-A0B9-4331-9E81-961355411485.html",
							"GUID-8305E5FB-D8B6-4824-AD2A-EFA4BF0DCDCD.html",
							"GUID-8305E5FB-D8B6-4824-AD2A-EFA4BF0DCDCD.html",
							"GUID-8305E5FB-D8B6-4824-AD2A-EFA4BF0DCDCD.html",
							"GUID-8305E5FB-D8B6-4824-AD2A-EFA4BF0DCDCD.html",
							"GUID-BEE2CEA6-760B-4433-B6F9-46FAD85BA076.html",
							"GUID-BEE2CEA6-760B-4433-B6F9-46FAD85BA076.html",
							"GUID-BEE2CEA6-760B-4433-B6F9-46FAD85BA076.html",
							"GUID-BEE2CEA6-760B-4433-B6F9-46FAD85BA076.html",
							"GUID-055E1A74-7370-4E9A-BDC6-FE5CA1547D14.html",
							"GUID-055E1A74-7370-4E9A-BDC6-FE5CA1547D14.html",
							"GUID-055E1A74-7370-4E9A-BDC6-FE5CA1547D14.html",
							"GUID-055E1A74-7370-4E9A-BDC6-FE5CA1547D14.html",
							"GUID-DE91F328-40E1-48BE-9E5D-8638A49014A1.html",
							"GUID-DE91F328-40E1-48BE-9E5D-8638A49014A1.html",
							"GUID-DE91F328-40E1-48BE-9E5D-8638A49014A1.html",
							"GUID-DE91F328-40E1-48BE-9E5D-8638A49014A1.html",
							"GUID-7DC907EC-3CE8-45F2-A78B-6AACDAEF6F52.html",
							"GUID-7DC907EC-3CE8-45F2-A78B-6AACDAEF6F52.html",
							"GUID-7DC907EC-3CE8-45F2-A78B-6AACDAEF6F52.html",
							"GUID-7DC907EC-3CE8-45F2-A78B-6AACDAEF6F52.html",
							"GUID-0F240AEF-6B53-4CD2-A8FD-1D16BA00B43E.html",
							"GUID-0F240AEF-6B53-4CD2-A8FD-1D16BA00B43E.html",
							"GUID-0F240AEF-6B53-4CD2-A8FD-1D16BA00B43E.html",
							"GUID-0F240AEF-6B53-4CD2-A8FD-1D16BA00B43E.html",
							"GUID-04628A3C-69FB-458A-B6A7-9CE08A6C26EB.html",
							"GUID-04628A3C-69FB-458A-B6A7-9CE08A6C26EB.html",
							"GUID-04628A3C-69FB-458A-B6A7-9CE08A6C26EB.html",
							"GUID-04628A3C-69FB-458A-B6A7-9CE08A6C26EB.html",
							"GUID-91BC6347-08EF-4EE7-ADDE-90524E70867A.html",
							"GUID-91BC6347-08EF-4EE7-ADDE-90524E70867A.html",
							"GUID-91BC6347-08EF-4EE7-ADDE-90524E70867A.html",
							"GUID-91BC6347-08EF-4EE7-ADDE-90524E70867A.html",
							"GUID-8A2DC2AD-7D43-4568-9CA7-325A8F1C64CA.html",
							"GUID-8A2DC2AD-7D43-4568-9CA7-325A8F1C64CA.html",
							"GUID-8A2DC2AD-7D43-4568-9CA7-325A8F1C64CA.html",
							"GUID-8A2DC2AD-7D43-4568-9CA7-325A8F1C64CA.html",
							"GUID-17FAEA79-D63F-4222-B015-DF863DD4AFA6.html",
							"GUID-17FAEA79-D63F-4222-B015-DF863DD4AFA6.html",
							"GUID-17FAEA79-D63F-4222-B015-DF863DD4AFA6.html",
							"GUID-17FAEA79-D63F-4222-B015-DF863DD4AFA6.html",
							"GUID-B70E454B-E9FB-4214-AC26-354C154592A1.html",
							"GUID-B70E454B-E9FB-4214-AC26-354C154592A1.html",
							"GUID-B70E454B-E9FB-4214-AC26-354C154592A1.html",
							"GUID-B70E454B-E9FB-4214-AC26-354C154592A1.html",
							"GUID-79B1C1D0-37E8-464B-82BE-41A226C2AB59.html",
							"GUID-79B1C1D0-37E8-464B-82BE-41A226C2AB59.html",
							"GUID-79B1C1D0-37E8-464B-82BE-41A226C2AB59.html",
							"GUID-79B1C1D0-37E8-464B-82BE-41A226C2AB59.html",
							"GUID-C340A70C-DB26-427E-B902-B253B1590DD7.html",
							"GUID-C340A70C-DB26-427E-B902-B253B1590DD7.html",
							"GUID-9F1A7B19-413E-4254-8E08-E61C7A180E8F.html",
							"GUID-9F1A7B19-413E-4254-8E08-E61C7A180E8F.html",
							"GUID-9F1A7B19-413E-4254-8E08-E61C7A180E8F.html",
							"GUID-9F1A7B19-413E-4254-8E08-E61C7A180E8F.html",
							"GUID-9F1A7B19-413E-4254-8E08-E61C7A180E8F.html",
							"GUID-9F1A7B19-413E-4254-8E08-E61C7A180E8F.html",
							"GUID-9F1A7B19-413E-4254-8E08-E61C7A180E8F.html",
							"GUID-897565A1-B722-4A0C-AE94-7C04BDEBEA4F.html",
							"GUID-897565A1-B722-4A0C-AE94-7C04BDEBEA4F.html",
							"GUID-897565A1-B722-4A0C-AE94-7C04BDEBEA4F.html",
							"GUID-897565A1-B722-4A0C-AE94-7C04BDEBEA4F.html",
							"GUID-897565A1-B722-4A0C-AE94-7C04BDEBEA4F.html",
							"GUID-897565A1-B722-4A0C-AE94-7C04BDEBEA4F.html",
							"GUID-897565A1-B722-4A0C-AE94-7C04BDEBEA4F.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-8C607133-0A31-4E3D-BDCC-A6CF5E5950B9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-846D93A7-8E39-4AB6-AF2F-99A20D770DB9.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-B0D9910C-94B2-4947-AC80-5CE869E553BB.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-6226C2BC-B29A-4FFD-BE21-B9B3EF06B446.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-28B1581E-648F-4F92-B376-19B1A46D81C3.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html",
							"GUID-383BAEE1-60DF-434C-B279-0E380732F844.html"];

var SearchTitles = ["MPLAB® Harmony 3 PIC32MZW1/WFI32 wireless system services",
"Contents Summary",
"Code Examples",
"App Debug System Service",
"App Debug System Service Usage",
"Description",
"Abstraction Model",
"App Debug System Service Configuration",
"App Debug System Service Interface",
"Data Types and Constants Summary",
"Initialization functions Summary",
"Setup functions Summary",
"APP_LOG_DBG_LVL Macro",
"C",
"Summary",
"Remarks",
"APP_LOG_ERROR_LVL Macro",
"C",
"Summary",
"Remarks",
"APP_LOG_FN_EE_LVL Macro",
"C",
"Summary",
"Remarks",
"APP_LOG_INFO_LVL Macro",
"C",
"Summary",
"Remarks",
"APP_LOG_LVL_DISABLE Macro",
"C",
"Summary",
"Remarks",
"SYS_APPDEBUG_MAX_NUM_OF_USERS Macro",
"C",
"Summary",
"Remarks",
"SYS_APPDEBUG_CtrlMsgType Enum",
"C",
"Summary",
"Remarks",
"SYS_APPDEBUG_RESULT Enum",
"C",
"Summary",
"Remarks",
"SYS_APPDEBUG_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_APPDEBUG_CtrlMsg Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_Deinitialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_Open Function",
"C",
"Summary",
"Description",
"Parameters",
"Example",
"Remarks",
"SYS_APPDEBUG_DBG_PRINT",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_ERR_PRINT",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_FN_ENTER_PRINT",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_FN_EXIT_PRINT",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_APPDEBUG_INFO_PRINT",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"MQTT System Service",
"MQTT System Service Usage",
"Description",
"Command Line",
"Abstraction Model",
"How The Library Works",
"MQTT System Service Configuration",
"MQTT System Service Interface",
"Data Types and Constants Summary",
"Initialization functions Summary",
"Status functions Summary",
"Setup functions Summary",
"Data Exchange functions Summary",
"SYS_MQTT_DEFAULT_NET_INTF Macro",
"C",
"Summary",
"Remarks",
"SYS_MQTT_INTF_ETHERNET Macro",
"C",
"Summary",
"Remarks",
"SYS_MQTT_INTF_WIFI Macro",
"C",
"Summary",
"Remarks",
"SYS_MQTT_EVENT_TYPE Enum",
"C",
"Summary",
"Remarks",
"SYS_MQTT_RESULT Enum",
"C",
"Summary",
"Remarks",
"SYS_MQTT_STATUS Enum",
"C",
"Summary",
"Remarks",
"SYS_MQTT_PublishConfig Struct",
"C",
"Summary",
"Remarks",
"SYS_MQTT_PublishTopicCfg Struct",
"C",
"Summary",
"Remarks",
"SYS_MQTT_Config Struct",
"C",
"Summary",
"Remarks",
"SYS_MQTT_SubscribeConfig Struct",
"C",
"Summary",
"Remarks",
"SYS_MQTT_BrokerConfig Struct",
"C",
"Summary",
"Remarks",
"SYS_MQTT_CALLBACK Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"SYS_MQTT_Deinitialize Function",
"C",
"Summary",
"Description",
"Example",
"Remarks",
"SYS_MQTT_Initialize Function",
"C",
"Summary",
"Description",
"Returns",
"Example",
"Remarks",
"SYS_MQTT_Connect Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_MQTT_Disconnect Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_MQTT_GetStatus Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_MQTT_Publish Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"SYS_MQTT_Subscribe Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"SYS_MQTT_Unsubscribe Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"SYS_MQTT_Task Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"MQTT System Service Developer's Guide",
"Overview",
"Detailed Design",
"State Machine",
"MQTT Client State Machine",
"Number of Subscription Topics Supported",
"Timeperiod for ACK",
"External APIs",
"SYS_MQTT_Connect ()",
"SYS_MQTT_Disconnect ()",
"SYS_MQTT_Publish ()",
"SYS_MQTT_Subscribe ()",
"SYS_MQTT_Unsubscribe ()",
"Handling of the messages received for a Topic",
"Handling of KeepAlive messages after the MQTT connection is UP",
"SYS_MQTT_Task ()",
"SYS_MQTT_Initialize ()/ SYS_MQTT_Deinitialize ()",
"CLI Commands",
"Code location",
"Reference",
"Net System Service",
"Net System Service Configuration",
"Net System Service Usage",
"Description",
"Command Line:",
"Abstraction Model",
"How The Library Works",
"Net System Service Interface",
"Data Types and Constants Summary",
"Initialization functions Summary",
"Status functions Summary",
"Setup functions Summary",
"Data Exchange functions Summary",
"SYS_NET_DEFAULT_AUTO_RECONNECT Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_DEFAULT_NET_INTF Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_DEFAULT_TLS_ENABLE Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_INTF_ETHERNET Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_INTF_WIFI Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_IP_PROT_TCP Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_MAX_HOSTNAME_LEN Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_IP_PROT_UDP Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_MAX_NUM_OF_SOCKETS Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_MODE_CLIENT Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_MODE_SERVER Macro",
"C",
"Summary",
"Remarks",
"NET_DATA Macro",
"C",
"Summary",
"Remarks",
"NET_CFG Macro",
"C",
"Summary",
"Remarks",
"SYS_NET_EVENT Enum",
"C",
"Summary",
"Remarks",
"SYS_NET_RESULT Enum",
"C",
"Summary",
"Remarks",
"SYS_NET_CTRL_MSG Enum",
"C",
"Summary",
"Remarks",
"SYS_NET_STATUS Enum",
"C",
"Summary",
"Remarks",
"SYS_NET_Config Struct",
"C",
"Summary",
"Remarks",
"SYS_NET_CALLBACK Typedef",
"C",
"SYS_NET_CALLBACK Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_NET_Initialize Function",
"C",
"Summary",
"Description",
"Returns",
"Example",
"Remarks",
"SYS_NET_Deinitialize Function",
"C",
"Summary",
"Description",
"Example",
"Remarks",
"SYS_NET_SetConfigParam Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_NET_Open Function",
"C",
"Summary",
"Description",
"Parameters",
"Example",
"Remarks",
"SYS_NET_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_NET_CtrlMsg Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_NET_GetStatus Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_NET_RecvMsg Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_NET_SendMsg Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_NET_Task Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Net System Service Developer's Guide",
"Overview",
"Detailed Design",
"State Machine",
"Client State Machine",
"Server State Machine",
"Number of Sockets Supported",
"External APIs",
"SYS_NET_Open ()",
"SYS_NET_Close ()",
"SYS_NET_SendMsg ()",
"SYS_NET_RecvMsg ()",
"Self-Healing",
"SYS_NET_Task ()",
"SYS_NET_CtrlMsg ()",
"SYS_NET_Initialize()/ SYS_NET_Deinitialize()",
"SYS_NET_SetConfigParam()",
"CLI Commands",
"Code location",
"Reference",
"Wi-Fi System Service",
"Wi-Fi System Service Usage",
"Abstraction Model",
"How The Library Works",
"Wi-Fi System Service Configuration",
"Configuration Options:",
"Device Mode:",
"STA Mode:",
"AP Mode:",
"Advanced configuration:",
"Enabling Wi-Fi System Service",
"Wi-Fi System Service Interface",
"Data Types and Constants Summary",
"Initialization functions Summary",
"Status functions Summary",
"Setup functions Summary",
"SYS_WIFI_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_MODE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_CTRLMSG Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_RESULT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_SCAN_MODES Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_AUTH Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_AP_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_STA_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_SCAN_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_STA_APP_INFO Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFI_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFI_CtrlMsg Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFI_Deinitialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFI_GetStatus Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFI_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFI_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"Wi-Fi System Service Developer's Guide",
"Code modification/implementation guide for common use cases",
"Wi-Fi System Service Auto Connect",
"Wi-Fi System Service Scan Example",
"How to Disconnect Connected STA in AP Mode Using Wi-Fi System Service",
"Wi-Fi provisioning System Service",
"Wi-Fi provisioning System Service Usage",
"Wi-Fi Provisioning Methods",
"Command line",
"TCP Socket mode",
"Wi-Fi provisioning with JSON format",
"Wi-Fi provisioning with Mobile Application",
"HTTP",
"Webpage using HTTP",
"Webpage using HTTPNET (Un-Secure)",
"Webpage using HTTPNET (Secure)",
"How The Library Works",
"Execution Flow",
"Wi-Fi provisioning System Service Configuration",
"Configuration Options:",
"Wi-Fi Provisioning System Service Interface",
"Data Types and Constants Summary",
"Initialization functions Summary",
"Status functions Summary",
"Setup functions Summary",
"SYS_WIFIPROV_CTRLMSG Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_RESULT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_MODE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_AUTH Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_AP_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_STA_CONFIG Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_WIFIPROV_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFIPROV_CtrlMsg Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFIPROV_Deinitialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFIPROV_GetStatus Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFIPROV_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WIFIPROV_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"Wi-Fi provisioning System Service Developer's Guide",
"Code modification/implementation guide for common use cases",
"**Adding New provisioning Method **",
"Over The Air (OTA) firmware update System Service",
"Key Features",
"OTA System Service Usage",
"Description",
"OTA Service Framework Architecture Overview",
"Abstraction model",
"OTA server JSON manifest",
"Factory Image Structure",
"Application Header Structure (boot control area)",
"Image download process",
"Block/Flow Diagram",
"Patch functionality",
"Securing OTA by verifying Images in Bootloader",
"Enabling Secure OTA",
"Verification of factory image",
"Generating Public Key and Private Key",
"Generating Signature",
"Providing Signature in Manifest file:",
"Provisioning TrustFlex parts for OTA FW Verification",
"Configuration fuses",
"Generating the OTA image",
"OTA server",
"Integrating bootloader",
"Resolving Data Conflict Compilation error",
"OTA System Service Configuration",
"Building custom logic",
"Easily registering user callbacks",
"OTA System Service Interface",
"Data Types and Constants Summary",
"Initialization functions Summary",
"Setup functions Summary",
"Registering call back function summary",
"SYS_OTA_STATES Enum",
"C",
"Summary",
"Description",
"SYS_OTA_RESULT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_OTA_CTRLMSG Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_OTA_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_OTA_Config Struct",
"C",
"Summary",
"Remarks",
"SYS_OTA_DATA Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_OTA_CALLBACK Typedef",
"C",
"SYS_OTA_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_OTA_CtrlMsg Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_OTA_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"Registering call back function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"OTA System Service Developer's Guide",
"OTA Service Architecture Overview",
"Code modification/implementation guide for common use cases",
"Registering a user defined callback for OTA system service",
"Check for updates on a custom trigger trigger :",
"Initiate OTA on user trigger :",
"How to trigger system reset (from application) on successful OTA completion with Autoreset option disabled in MHC :",
"How to limit periodic OTA check for a definite number of times :",
"What will happen if an image is downloaded successfully but image digest verify fails :",
"How developer can trigger periodic update check when a user defined condition is satisfied (e g : switch pressed) :",
"How to get download status during OTA update :",
"Web Socket Server (WSS) System Service",
"Web Socket Server System Service Usage",
"Description",
"Abstraction Model",
"How the service works",
"Web Socket Server System Service Initialization",
"Web Socket Server System Service API usage",
"Web Socket Server (WSS) System Service Configuration",
"Web Socket Server System Service Interface",
"Data Types and Constants Summary",
"Initialization functions Summary",
"Data Exchange functions Summary",
"SYS_WSS_GUID Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_CLIENT_KEY_SIZE Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_CLIENT_KEY_SIZE_DECODED Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_HTTP_VERSION_1_1 Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_KA_TIMER_PERIOD Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_SERVER_KEY_SIZE Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_SHA1_DIGEST_SIZE Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_STATUS_CODE_LEN Macro",
"C",
"Summary",
"Remarks",
"SYS_WSS_RESULT Enum",
"C",
"Summary",
"Remarks",
"SYS_WSS_EVENTS Enum",
"C",
"Summary",
"Remarks",
"SYS_WSS_STATE Enum",
"C",
"Summary",
"Remarks",
"SYS_WSS_FRAME Enum",
"C",
"Summary",
"Remarks",
"SYS_WSS_STATUS_CODE Enum",
"C",
"Summary",
"Remarks",
"SYS_WSS_HANDSHAKE_CTXT Struct",
"C",
"Summary",
"Remarks",
"SYS_WSS_RXDATA Struct",
"C",
"Summary",
"Remarks",
"SYS_WSS_CONFIG Struct",
"C",
"Summary",
"Remarks",
"SYS_WSS_CALLBACK Typedef",
"C",
"SYS_WSS_Initialize Function",
"C",
"Summary",
"Description",
"Returns",
"Example",
"Remarks",
"SYS_WSS_Deinitialize Function",
"C",
"Summary",
"Description",
"Returns",
"Example",
"Remarks",
"SYS_WSS_PingClient Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WSS_register_callback Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WSS_sendMessage Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WSS_CloseConnection Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_WSS_Task Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Web Socket Server System Service Developer's Guide",
"Overview",
"Detailed Design",
"State Machine",
"Number of Clients Supported",
"Client time out",
"API Implementation",
"SYS_WSS_register_callback()",
"SYS_WSS_CloseConnection()",
"SYS_WSS_PingClient()",
"SYS_WSS_sendMessage()",
"SYS_WSS_Initialize() / SYS_WSS_Deinitialize()",
"Code location"];

var SearchInfo = [" MPLAB® Harmony 3 PIC32MZW1/WFI32 wireless system services MPLAB® Harmony 3 is an extension of the MPLAB® ecosystem for creating embedded firmware solutions for Microchip 32-bit SAM and PIC® microcontroller and microprocessor devices Refer to the following links for more information Microchip 32-bit MCUs Microchip 32-bit MPUs Microchip MPLAB X IDE Microchip MPLAB® Harmony Microchip MPLAB® Harmony Pages This repository contains the MPLAB® Harmony 3 Wireless wireless system services for the PIc32MZW1/WFI32 family of devices Wireless system services absstracts out the complexities of a networked system design and simplifies development using PIC32MZW1 and WFI32 Refer to the following links for release notes training materials and interface reference information Release Notes MPLAB® Harmony License MPLAB® Harmony 3 Wireless API Help PIc32MZW1 / WFI32 Software Users Guide ",
							" Contents Summary Folder Description system Contains Wireless service code and configuration files docs Contains documentation in html format for offline viewing (to be used only after cloning this repository onto a local machine) Use github pages of this repository for viewing it online ",
							" Code Examples Wireless subsystem code examples for PIC32MZW1/WFI32 can be found in the wireless_apps_pic32mzw1_wfi32e01 repo ",
							" App Debug System Service App Debug System Service Library provides an application programming interface (API) to manage debug logs at runtime Key Features: Supports Enabling/ Disabling of logs at runtime Supports Enabling/ Disabling of logs based on severity level Supports Enabling/ Disabling of logs based on logical flow The App Debug System Service provides simple API's to enable/diable system console logs functionalities Multiple users can request the App Debug system service functionalities simultaneously ",
							" App Debug System Service Usage ",
							" Description The App Debug System Service provides simple APIs to enable/ disable logs at runtime based on the log levels and flow More on how any component using this library can enabling/ disable logs at runtime can go through the system services like the MQTT NET and Wifi System Service ",
							" Abstraction Model The App Debug System Service library provides an abstraction to the System Console Lohs to provide following functionalities - Enabling/ disabling of logs at runtime - Enabling/ disabling of logs based on severity level - Enabling/ disabling of logs based on logical flows e g Data Flow Control Flow etc ",
							" App Debug System Service Configuration The enabling/ disabling of App Debug System Service library should be done through the MHC More on how any component can integrate this library into his own component can be found by going through some of the system services like the MQTT NET and Wifi System Service Note that App Debug System Service component does not have any conifgurations to be done separately All the configurations needs to come via the other components using it ",
							" App Debug System Service Interface ",
							" Data Types and Constants Summary Name Description APP_LOG_LVL_DISABLE App Debug Service Logging Disabled APP_LOG_ERROR_LVL App Debug Service Error Log Level APP_LOG_DBG_LVL App Debug Service Debug Log Level APP_LOG_INFO_LVL App Debug Service Info Log Level APP_LOG_FN_EE_LVL App Debug Service Service Entry/ Exit Log Level SYS_APPDEBUG_MAX_NUM_OF_USERS Number of instances of App Debug Service supported SYS_APPDEBUG_CONFIG Defines the data required to initialize the app debug system service SYS_APPDEBUG_CtrlMsgType Identifies the control message for which the User has called the SYS_APPDEBUG_CtrlMsg() SYS_APPDEBUG_RESULT Identifies the return values for the Sys App Debug APIs ",
							" Initialization functions Summary Name Description SYS_APPDEBUG_Initialize Returns success/ failure for initialization of data structures of the SYS_APPDEBUG_Deinitialize Returns success/ failure for deinitialization of data structures of the ",
							" Setup functions Summary Name Description SYS_APPDEBUG_Open Open an instance of the System App Debug service SYS_APPDEBUG_Close Close the specific module instance of the SYS App Debug service SYS_APPDEBUG_CtrlMsg Returns success/ failure for the flow/ level set operation asked by the user SYS_APPDEBUG_ERR_PRINT Used for logging Error Level Logs SYS_APPDEBUG_DBG_PRINT Used for logging Debug Level Logs SYS_APPDEBUG_INFO_PRINT Used for logging Info Level Logs SYS_APPDEBUG_FN_ENTER_PRINT Used for logging Function Entry Logs SYS_APPDEBUG_FN_EXIT_PRINT Used for logging Function Exit Logs ",
							" APP_LOG_DBG_LVL Macro ",
							" C #define APP_LOG_DBG_LVL 0x2 ",
							" Summary App Debug Service Debug Log Level ",
							" Remarks None ",
							" APP_LOG_ERROR_LVL Macro ",
							" C #define APP_LOG_ERROR_LVL 0x1 ",
							" Summary App Debug Service Error Log Level ",
							" Remarks None ",
							" APP_LOG_FN_EE_LVL Macro ",
							" C #define APP_LOG_FN_EE_LVL 0x8 ",
							" Summary App Debug Service Service Entry/ Exit Log Level ",
							" Remarks None ",
							" APP_LOG_INFO_LVL Macro ",
							" C #define APP_LOG_INFO_LVL 0x4 ",
							" Summary App Debug Service Info Log Level ",
							" Remarks None ",
							" APP_LOG_LVL_DISABLE Macro ",
							" C #define APP_LOG_LVL_DISABLE 0x0 ",
							" Summary App Debug Service Logging Disabled ",
							" Remarks None ",
							" SYS_APPDEBUG_MAX_NUM_OF_USERS Macro ",
							" C #define SYS_APPDEBUG_MAX_NUM_OF_USERS 8 ",
							" Summary Number of instances of App Debug Service supported ",
							" Remarks None ",
							" SYS_APPDEBUG_CtrlMsgType Enum ",
							" C typedef enum { SYS_APPDEBUG_CTRL_MSG_TYPE_SET_LEVEL SYS_APPDEBUG_CTRL_MSG_TYPE_SET_FLOW } SYS_APPDEBUG_CtrlMsgType; ",
							" Summary Identifies the control message for which the User has called the SYS_APPDEBUG_CtrlMsg() ",
							" Remarks None ",
							" SYS_APPDEBUG_RESULT Enum ",
							" C typedef enum { SYS_APPDEBUG_SUCCESS = 0 // Success SYS_APPDEBUG_FAILURE = -1 // Failure } SYS_APPDEBUG_RESULT; ",
							" Summary Identifies the return values for the Sys App Debug APIs ",
							" Remarks None ",
							" SYS_APPDEBUG_CONFIG Struct ",
							" C typedef struct { /* Initial system Log level setting */ unsigned int logLevel; /* Initial system Log level setting */ unsigned int logFlow; /* Initial system Log level setting */ const char *prefixString; } SYS_APPDEBUG_CONFIG; ",
							" Summary Defines the data required to initialize the app debug system service ",
							" Description This structure defines the data required to initialize the app debug system service ",
							" Remarks None ",
							" SYS_APPDEBUG_CtrlMsg Function ",
							" C int32_t SYS_APPDEBUG_CtrlMsg(SYS_MODULE_OBJ obj SYS_APPDEBUG_CtrlMsgType eCtrlMsgType void *data uint16_t len) ",
							" Summary Returns success/ failure for the flow/ level set operation asked by the user ",
							" Description This function is used for setting the value of floe/ level for the app debug logs ",
							" Precondition SYS_APPDEBUG_Open should have been called ",
							" Parameters obj - SYS App Debug object handle returned from SYS_APPDEBUG_Open | Param | Description | |:----- |:----------- | | eCtrlMsgType | valid Msg Type data - valid data buffer pointer based on the Msg Type len - length of the data buffer the pointer is pointing to ",
							" Returns SYS_APPDEBUG_SUCCESS - Indicates that the Request was catered to successfully SYS_APPDEBUG_FAILURE - Indicates that the Request failed ",
							" Example // Handle \"objSysAppDebug\" value must have been returned from SYS_APPDEBUG_Open uint32_t logLevel = 0x3; if( SYS_APPDEBUG_CtrlMsg(objSysAppDebug SYS_APPDEBUG_CTRL_MSG_TYPE_SET_LEVEL logLevel 4) == SYS_APPDEBUG_SUCCESS) { } ",
							" Remarks None ",
							" SYS_APPDEBUG_Close Function ",
							" C void SYS_APPDEBUG_Close ( SYS_MODULE_OBJ object ) ",
							" Summary Close the specific module instance of the SYS App Debug service ",
							" Description This function clsoes the specific module instance disabling its operation Resets all of the internal data structures and fields for the specified instance to the default settings ",
							" Precondition The SYS_APPDEBUG_Open function should have been called before calling this function ",
							" Parameters Param Description object SYS App Debug object handle returned from SYS_APPDEBUG_Open ",
							" Returns None ",
							" Example // Handle \"objSysAppDebug\" value must have been returned from SYS_APPDEBUG_Open SYS_APPDEBUG_Close (objSysAppDebug); ",
							" Remarks Once the Open operation has been called the Close operation must be called before the Open operation can be called again ",
							" SYS_APPDEBUG_Deinitialize Function ",
							" C int32_t SYS_APPDEBUG_Deinitialize() ",
							" Summary Returns success/ failure for deinitialization of data structures of the App Debug service ",
							" Description This function is used for deinitializing the data structures of the App Debug service and is called from within the System Task ",
							" Parameters None ",
							" Returns SYS_APPDEBUG_SUCCESS - Indicates the data structures were deinitialized successfully SYS_APPDEBUG_FAILURE - Indicates that it failed to deinitialize the data structures ",
							" Example if( SYS_APPDEBUG_Deinitialize() == SYS_APPDEBUG_SUCCESS) { } ",
							" Remarks If the Net system service is enabled using MHC then auto generated code will take care of system task execution ",
							" SYS_APPDEBUG_Initialize Function ",
							" C int32_t SYS_APPDEBUG_Initialize() ",
							" Summary Returns success/ failure for initialization of data structures of the App Debug service ",
							" Description This function is used for initializing the data structures of the App Debug service and is called from within the System Task ",
							" Parameters index - NULL; reserved for future use init - NULL; reserved for future use ",
							" Returns SYS_APPDEBUG_SUCCESS - Indicates the data structures were initialized successfully SYS_APPDEBUG_FAILURE - Indicates that it failed to initialize the data structures ",
							" Example if( SYS_APPDEBUG_Initialize(NULL NULL) == SYS_APPDEBUG_SUCCESS) { } ",
							" Remarks If the Net system service is enabled using MHC then auto generated code will take care of system task execution ",
							" SYS_APPDEBUG_Open Function ",
							" C SYS_MODULE_OBJ SYS_APPDEBUG_Open (SYS_APPDEBUG_CONFIG *cfg) ",
							" Summary Open an instance of the System App Debug service ",
							" Description This function initializes the instance of the System App Debug Service ",
							" Parameters cfg - Configuration with which the App Debug Service needs to be opened ##Returns Returns:If successful returns a valid handle to an object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_APPDEBUG_CONFIG g_AppDebugServCfg; SYS_MODULE_OBJ g_AppDebugServHandle; memset( g_AppDebugServCfg 0 sizeof(g_AppDebugServCfg)); g_AppDebugServCfg logLevel |= APP_LOG_ERROR_LVL; g_AppDebugServCfg prefixString = \"MY_APP\"; g_AppDebugServCfg logFlow |= 0x1; g_AppDebugServHandle = SYS_NET_Open( g_AppDebugServCfg); if (g_AppDebugServHandle == SYS_MODULE_OBJ_INVALID) { // Handle error } ",
							" Remarks This routine should be called everytime a user wants to open a new NET socket ",
							" SYS_APPDEBUG_DBG_PRINT ",
							" C #define SYS_APPDEBUG_DBG_PRINT(obj flow fmt ) SYS_APPDEBUG_PRINT(obj flow APP_LOG_DBG_LVL __FUNCTION__ __LINE__ fmt ##__VA_ARGS__) ",
							" Summary Used for logging Debug Level Logs ",
							" Description This macro function is used for logging debug level logs ",
							" Precondition SYS_APPDEBUG_Open should have been called ",
							" Parameters obj - SYS App Debug object handle returned from SYS_APPDEBUG_Open flow - valid flow defined by the User log will come only if this flow is enabled data - valid string - any variable arguments if present ",
							" Returns None ",
							" Example // Handle \"objSysAppDebug\" value must have been returned from SYS_APPDEBUG_Open SYS_APPDEBUG_DBG_PRINT(objSysAppDebug MY_APP_FLOW_DATA \"memory allocation reached Threshold\"); ",
							" Remarks None ",
							" SYS_APPDEBUG_ERR_PRINT ",
							" C #define SYS_APPDEBUG_ERR_PRINT(obj flow fmt ) SYS_APPDEBUG_PRINT(obj flow APP_LOG_ERROR_LVL __FUNCTION__ __LINE__ fmt ##__VA_ARGS__) ",
							" Summary Used for logging Error Level Logs ",
							" Description This macro function is used for logging error level logs ",
							" Precondition SYS_APPDEBUG_Open should have been called ",
							" Parameters obj - SYS App Debug object handle returned from SYS_APPDEBUG_Open flow - valid flow defined by the User log will come only if this flow is enabled data - valid string - any variable arguments if present ",
							" Returns None ",
							" Example // Handle \"objSysAppDebug\" value must have been returned from SYS_APPDEBUG_Open SYS_APPDEBUG_ERR_PRINT(objSysAppDebug MY_APP_FLOW_DATA \"Failed to allocate memory of size %d\" size); ",
							" Remarks None ",
							" SYS_APPDEBUG_FN_ENTER_PRINT ",
							" C #define SYS_APPDEBUG_FN_ENTER_PRINT(obj flow) SYS_APPDEBUG_PRINT_FN_ENTER(obj flow __FUNCTION__ __LINE__) ",
							" Summary Used for logging Function Entry Logs ",
							" Description This macro function is used for logging function entry level logs ",
							" Precondition SYS_APPDEBUG_Open should have been called ",
							" Parameters obj - SYS App Debug object handle returned from SYS_APPDEBUG_Open flow - valid flow defined by the User log will come only if this flow is enabled data - valid string - any variable arguments if present ",
							" Returns None ",
							" Example // Handle \"objSysAppDebug\" value must have been returned from SYS_APPDEBUG_Open SYS_APPDEBUG_FN_ENTER_PRINT(objSysAppDebug MY_APP_FLOW_DATA); ",
							" Remarks None ",
							" SYS_APPDEBUG_FN_EXIT_PRINT ",
							" C #define SYS_APPDEBUG_FN_EXIT_PRINT(obj flow) SYS_APPDEBUG_PRINT_FN_EXIT(obj flow __FUNCTION__ __LINE__) ",
							" Summary Used for logging Function Exit Logs ",
							" Description This macro function is used for logging function exit level logs ",
							" Precondition SYS_APPDEBUG_Open should have been called ",
							" Parameters obj - SYS App Debug object handle returned from SYS_APPDEBUG_Open flow - valid flow defined by the User log will come only if this flow is enabled data - valid string - any variable arguments if present ",
							" Returns None ",
							" Example // Handle \"objSysAppDebug\" value must have been returned from SYS_APPDEBUG_Open SYS_APPDEBUG_FN_EXIT_PRINT(objSysAppDebug MY_APP_FLOW_DATA); ",
							" Remarks None ",
							" SYS_APPDEBUG_INFO_PRINT ",
							" C #define SYS_APPDEBUG_INFO_PRINT(obj flow fmt ) SYS_APPDEBUG_PRINT(obj flow APP_LOG_INFO_LVL __FUNCTION__ __LINE__ fmt ##__VA_ARGS__) ",
							" Summary Used for logging Info Level Logs ",
							" Description This macro function is used for logging info level logs ",
							" Precondition SYS_APPDEBUG_Open should have been called ",
							" Parameters obj - SYS App Debug object handle returned from SYS_APPDEBUG_Open flow - valid flow defined by the User log will come only if this flow is enabled data - valid string - any variable arguments if present ",
							" Returns None ",
							" Example // Handle \"objSysAppDebug\" value must have been returned from SYS_APPDEBUG_Open SYS_APPDEBUG_INFO_PRINT(objSysAppDebug MY_APP_FLOW_DATA \"Allocate memory of size %d\" size); ",
							" Remarks None ",
							" MQTT System Service MQTT System Service Library provides an application programming interface (API) to manage MQTT functionalities The MQTT System Service internally uses the third party Paho MQTT software for MQTT support Key Features: Supports MQTT Client Supports TLS for MQTT Connection Supports Self Healing that is if the connection for some reason breaks the service shall take care of reconnecting the same internally The MQTT System Service provides simple API's to enable MQTT functionalities like publishing and subscribing to a topic ",
							" MQTT System Service Usage ",
							" Description The MQTT System Service provides simple APIs to enable MQTT Client Connectivity to a configured MQTT Broker The User need not take care of intermediate states of a MQTT Connection as the Service internally takes care of that User is not required to have Security domain knowledge to establish a secured connection via the application using MQTT System Service library ",
							" Command Line User can follow below commands for MQTT System Service: 1 sysmqtthelp MQTT System Service help command which displays the supported CLI commands sysmqtthelp_cli 2 sysmqtt open Command for Reconfiguring an already open instance of MQTT System Service sysmqttopen_cli Note: Once the User has configured all the params the last command for opening the new connection should 'sysmqtt open apply' 3 sysmqtt close Command to close the instance of MQTT System Service sysmqttclose_cli 4 sysmqtt send Command to send message on a topic for the instance of MQTT System Service sysmqttsend_cli 5 sysmqtt sunbscribe Command to subscribe to a topic to receive message coming on that topic sysmqttsubscribe_cli 6 sysmqtt unsunbscribe Command to unsubscribe from a topic sysmqttunsubscribe_cli 7 sysmqtt get info Command for knowing the Current Information for all the Instances of Net System Service sysmqttgetinfo_cli ",
							" Abstraction Model The MQTT System Service library provides an abstraction to the MQTT APIs to provide following functionalities Connectivity for MQTT Client Secured Connectivity using TLS Self Healing Reduce code user has to write Reduce time to develop and maintain The following diagram depicts the MQTT System Service abstraction model MqttService_abstract ",
							" How The Library Works By default MHC generated code provides all the functionalities to enable MQTT Client applicatation with secured or unsecured connectivity User needs to configure the required MQTT Brokerconfiguration using MHC User needs to call the SYS_MQTT_Connect() API with a valid callback to open an instance of the MQTT Client configured in the MHC MqttConnect The User Application is expected to call SYS_MQTT_Task() API periodically as this API ensures that the MQTT System service is able to execute its state machine to process any messages and invoke the user callback for any events The User Application can call SYS_MQTT_Publish()/ SYS_MQTT_Subscribe() API in case it wants to publish message to a topic or receive messages on a topic MqttPublish MqttSubscribe The User Application when enables Auto-Reconnect it enables the self healing feature of the MQTT Service When this feature is enabled the service will automatically try to establish connection with the MQTT Broker whenever a connection breaks MqttSelfHealing ",
							" MQTT System Service Configuration The MQTT System Service library should be configured through the MHC When user selects the MQTT System Service library all the required dependencies components are added automatically in the MHC configuration The following figure shows the MHC configuration window for configuring the MQTT System Service and a brief description of various configuration options Open the MHC 3 Drag the MQTT Service Module into the Active components from the Available components Mqtt_service_MHC Configure the various parameters of Basic Configuration Mqtt_Basic_Service Parameter Name Default Value Description Broker Name  Name of the MQTT BrokerNote: User should ensure that the Broker is UP and running In case the connection timesout often the User can modify the value of SYS_MQTT_PERIOIDC_TIMEOUT as per his requirement Server Port  Port number of the MQTT Broker at which the MQTT Client should connect Enable TLS FALSE If TRUE the MQTT connection should use TLS while connecting to the broker If FALSE the MQTT connection should not use TLS Note: In case the TLS is enabled the User needs to update the component 'Presentation Layer' with the CA Certificate format location name and size Other parameters can be updated as per the User's requirements Enable SNI FALSE Server Name Indication ff TRUE enables a client device to specify the domain name it is trying to reach in the first step of the TLS handshake Note: In case the SNI is enabled the Broker Name is taken as the Domain Name Enable ALPN FALSE Application-Layer Protocol Negotiation (ALPN) is a TLS extension that allows the application layer to negotiate which protocol should be performed over a secure connection in a manner that avoids additional round trips and which is independent of the application-layer protocols Client Id  MQTT Client Id should be unique for the Broker If left empty the Id will be generated randomly Network Interface  Network Interface - Wifi or Ethernet on which the MQTT Client should run On choosing Ethernet the MHC will add EthMAC MIIM and LAM8740 Components The User needs to attach the EthMAC to the NetConfig (in System Component Window) via the MAC parameter in Instance 1 Net_service_netconfig Configure the various parameters of Presentation Layer if TLS enabled presentation_layer Configure the various parameters of 'Advanced Configuration' of the MQTT Service Mqtt_Adv_Service Parameter Name Default Value Description Enable Auto Reconnect TRUE If TRUE the MQTT Service will auto reconnect to the Broker if connection is broken If FALSE the customer application needs to take care of triggering the connection process again Enable Clean Session TRUE If TRUE the MQTT Client shall tell the Broker that the session is clean; else it will let the Broker know that the session is a continuation of the previous session Also if “clean session” is disabled it is valid only within a single boot session in the Client (i e reconnecting before the next power-on reset) and not across boots KeepAlive Interval 60 sec If no data flows over an open connection for a certain KeepAliveInterval then the client will generate a PINGREQ and expect to receive a PINGRESP from the broker This message exchange confirms that the connection is open and working Username/ Password Disabled In case the connection to Broker needs a Username and Password Last Will and testament Disabled LWT Configuration has the following parameters – 1 Topic 2 QoS 3 Retain and 4 Message This ‘Message’ will be sent on the ‘Topic’ whenever the Broker finds that there is an ungraceful disconnection with the Client Configure the remaining parameters Mqtt_Remaining_Service Parameter Name Default Value Description Subscription Topic Disabled Subscription configuration has 2 Parameters – 1 Topic and 2 Qos (0 (Atmost Once) 1 (Atleast Once) 2 (Exactly Once)) The User can configure these parameters to subscribe to a Topic to receive messages Publish to Topic Disabled Publishing a message to Topic has 3 Parameters – 1 Topic and 2 Qos ( 0 (Atmost Once) 1 (Atleast Once) 2 (Exactly Once)) 3 Retain: If the Broker should retain the message The User can configure these parameters to and use them along with the message to send it on a particular Topic Enable CLI Commands Enabled Enabling this flag compiles in the CLI commands related to Mqtt Service The user can use these CLI commands to connect/ disconnect subscribe/ unsusbscribe publish messages onto a topic Enable Debug Logs Disabled Enabling this flag compiles in debug logs and user can enable them at runtime The user can use the following CLI commands to enable/ disable levels and flows for the MQTT service: 1 sysmqtt debug level 2 sysmqtt debug flow Note: In case the user enables debug logs user needs to manually add the 'App Debug Service' component from Wireless- System Service- App Debug Service To use the device certificates stored in ATECC608A-TNGTLS enable the \"Trust Go client certificate\" option under the net service configurations Make sure that you enable TLS in the MQTT configuration to use the client certificate during the TLS handshake TNGTLS_ClientCert All of the required files are automatically added into the MPLAB X IDE project by the MHC when the MQTT Service is selected for use ",
							" MQTT System Service Interface ",
							" Data Types and Constants Summary Name Description SYS_MQTT_INTF_WIFI Mqtt Socket Intf - Wifi SYS_MQTT_INTF_ETHERNET Mqtt Socket Intf - Ethernet SYS_MQTT_STATUS Identifies the current status of the Sys Mqtt Instance SYS_MQTT_RESULT Identifies the return values for the Sys Mqtt APIs SYS_MQTT_BrokerConfig Used for passing on the configuration related to the MQTT Broker SYS_MQTT_SubscribeConfig Used for passing on the configuration related to the MQTT Subtopics the user SYS_MQTT_PublishConfig Used for Reading the message that has been received on a topic subscribed to SYS_MQTT_PublishTopicCfg Used for publishing a message on a topic It contains the config related to the Topic SYS_MQTT_EVENT_TYPE Event Message Type which comes with the Callback SYS_MQTT_CALLBACK() SYS_MQTT_Config Used for passing on the configuration related to the either MQTT Broker ",
							" Initialization functions Summary Name Description SYS_MQTT_Initialize Returns success/ failure for initialization of data structures of the MQTT service SYS_MQTT_Deinitialize Deinitialization of data structures of the MQTT service ",
							" Status functions Summary Name Description SYS_MQTT_GetStatus Returns System MQTT instance status ",
							" Setup functions Summary Name Description SYS_MQTT_Connect Connects to the configured MQTT Broker SYS_MQTT_Disconnect Disconnects from the MQTT Server SYS_MQTT_Task Executes the MQTT Service State Machine SYS_MQTT_Subscribe Returns success/ failure for the subscribing to a Topic by the user SYS_MQTT_Unsubscribe Returns success/ failure for the unsubscribing to a Topic by the user ",
							" Data Exchange functions Summary Name Description SYS_MQTT_Publish Returns success/ failure for the publishing of message asked by the user SYS_MQTT_CALLBACK Pointer to a MQTT system service callback function ",
							" SYS_MQTT_DEFAULT_NET_INTF Macro ",
							" C #define SYS_MQTT_DEFAULT_NET_INTF 0 ",
							" Summary Default Value for network interface - 0 (Wifi) ",
							" Remarks None ",
							" SYS_MQTT_INTF_ETHERNET Macro ",
							" C #define SYS_MQTT_INTF_ETHERNET SYS_NET_INTF_ETHERNET // Ethernet Intf Value ",
							" Summary Mqtt Socket Intf - Ethernet ",
							" Remarks None ",
							" SYS_MQTT_INTF_WIFI Macro ",
							" C #define SYS_MQTT_INTF_WIFI SYS_NET_INTF_WIFI // Wifi Intf Value ",
							" Summary Mqtt Socket Intf - Wifi ",
							" Remarks None ",
							" SYS_MQTT_EVENT_TYPE Enum ",
							" C typedef enum { //Message received on a topic subscribed to SYS_MQTT_EVENT_MSG_RCVD = 0 //MQTT Client for Disconnected SYS_MQTT_EVENT_MSG_DISCONNECTED //MQTT Client Connected SYS_MQTT_EVENT_MSG_CONNECTED //MQTT Client Subscribed to a Grp SYS_MQTT_EVENT_MSG_SUBSCRIBED //MQTT Client UnSubscribed from a Grp SYS_MQTT_EVENT_MSG_UNSUBSCRIBED //MQTT Client Published to a Grp SYS_MQTT_EVENT_MSG_PUBLISHED //MQTT Client ConnAck TimeOut SYS_MQTT_EVENT_MSG_CONNACK_TO //MQTT Client SubAck TimeOut SYS_MQTT_EVENT_MSG_SUBACK_TO //MQTT Client PubAck TimeOut SYS_MQTT_EVENT_MSG_PUBACK_TO //MQTT Client PubAck TimeOut SYS_MQTT_EVENT_MSG_UNSUBACK_TO } SYS_MQTT_EVENT_TYPE; ",
							" Summary Event Message Type which comes with the Callback SYS_MQTT_CALLBACK() informing the user of the event that has occured ",
							" Remarks None ",
							" SYS_MQTT_RESULT Enum ",
							" C typedef enum { // Success SYS_MQTT_SUCCESS = 0 // Failure SYS_MQTT_FAILURE = -1 // Sys NET Service Down SYS_MQTT_SERVICE_DOWN = -2 // Sys NET Available Put Buffer not enough for xmitting the Data SYS_MQTT_SEM_OPERATION_FAILURE = -5 // Sys NET Invalid Handle SYS_MQTT_INVALID_HANDLE = -6 } SYS_MQTT_RESULT; ",
							" Summary Identifies the return values for the Sys Mqtt APIs ",
							" Remarks None ",
							" SYS_MQTT_STATUS Enum ",
							" C typedef enum { // Idle SYS_MQTT_STATUS_IDLE = 0 // Lower Layer is DOWN SYS_MQTT_STATUS_LOWER_LAYER_DOWN // Net Client connecting to Net Server SYS_MQTT_STATUS_SOCK_CLIENT_CONNECTING // Net Instance connected to the peer SYS_MQTT_STATUS_SOCK_CONNECTED // Net Instance Failed to open socket SYS_MQTT_STATUS_SOCK_OPEN_FAILED // Lower Layer is DOWN SYS_MQTT_STATUS_MQTT_CONNECTED // Net Instance in disconnected state SYS_MQTT_STATUS_MQTT_DISCONNECTING // Net Instance in disconnected state SYS_MQTT_STATUS_MQTT_DISCONNECTED // Wait for Connect Ack from Broker SYS_MQTT_STATUS_WAIT_FOR_MQTT_CONACK // Wait for Subscribe Ack from Broker SYS_MQTT_STATUS_WAIT_FOR_MQTT_SUBACK // Wait for Publish Ack from Broker SYS_MQTT_STATUS_WAIT_FOR_MQTT_PUBACK // Wait for Unsibscribe Ack from Broker SYS_MQTT_STATUS_WAIT_FOR_MQTT_UNSUBACK } SYS_MQTT_STATUS; ",
							" Summary Identifies the current status of the Sys Mqtt Instance ",
							" Remarks None ",
							" SYS_MQTT_PublishConfig Struct ",
							" C typedef struct { //Qos (0/ 1/ 2) uint8_t qos; //Retain (0/1) - Message needs to be retained by the Broker till every subscriber receives it uint8_t retain; //Message to be Published uint8_t message[SYS_MQTT_MSG_MAX_LEN]; //Message Length uint16_t messageLength; //Topic on which to Publish the message char *topicName; //Topic Length uint16_t topicLength; } SYS_MQTT_PublishConfig; ",
							" Summary Used for Reading the message that has been received on a topic subscribed to The structure is also used for passing on the LWT config when connecting to MQTT Broker ",
							" Remarks This Message is passed to the Application via the SYS_MQTT_CALLBACK() function ",
							" SYS_MQTT_PublishTopicCfg Struct ",
							" C typedef struct { //Qos (0/ 1/ 2) uint8_t qos; //Retain (0/1) - Message needs to be retained by the Broker till every subscriber receives it uint8_t retain; //Topic on which to Publish the message char topicName[SYS_MQTT_TOPIC_NAME_MAX_LEN]; //Topic Length uint16_t topicLength; } SYS_MQTT_PublishTopicCfg; ",
							" Summary Used for publishing a message on a topic It contains the config related to the Topic ",
							" Remarks This Message is passed from the Application to the MQTT servuce via the SYS_MQTT_Publish() function ",
							" SYS_MQTT_Config Struct ",
							" C typedef struct { //MQTT Broker Configuration SYS_MQTT_BrokerConfig sBrokerConfig; //Number of Topis Subscribed to (0-SYS_MQTT_MAX_TOPICS) uint8_t subscribeCount; //Config for all the Topics Subscribed to SYS_MQTT_SubscribeConfig sSubscribeConfig[SYS_MQTT_SUB_MAX_TOPICS]; //If last will and testament(LWT) is enabled or not bool bLwtEnabled; // LWT Configuration SYS_MQTT_PublishConfig sLwtConfig; //Network Interface - Wifi or Ethernet uint8_t intf; } SYS_MQTT_Config; ",
							" Summary Used for passing on the configuration related to the either MQTT Broker or the Cloud Vendors AWS/ Azure etc ",
							" Remarks None ",
							" SYS_MQTT_SubscribeConfig Struct ",
							" C typedef struct { uint8_t entryValid; //Qos (0/ 1/ 2) uint8_t qos; //Name of the Topic Subscribing to char topicName[SYS_MQTT_TOPIC_NAME_MAX_LEN]; } SYS_MQTT_SubscribeConfig; ",
							" Summary Used for passing on the configuration related to the MQTT Subtopics the user wants to subscribe to ",
							" Remarks This Configuration is passed via the SYS_MQTT_Connect() function or the SYS_MQTT_CtrlMsg() function ",
							" SYS_MQTT_BrokerConfig Struct ",
							" C typedef struct { //to know which of the Configurations are valid SYS_MQTT_Vendor_Type eVendorType; // MQTT Broker/ Server Name char brokerName[SYS_MQTT_MAX_BROKER_NAME_LEN]; // MQTT Server Port uint16_t serverPort; // Keep Alive Interval for the Mqtt Session uint16_t keepAliveInterval; // MQTT Client ID char clientId[SYS_MQTT_CLIENT_ID_MAX_LEN]; // MQTT Username char username[SYS_MQTT_USER_NAME_MAX_LEN]; // MQTT password char password[SYS_MQTT_PASSWORD_MAX_LEN]; // TLS is Enabled bool tlsEnabled; // AutoConnect is Enabled bool autoConnect; // Clean Session is Enabled bool cleanSession; } SYS_MQTT_BrokerConfig; ",
							" Summary Used for passing on the configuration related to the MQTT Broker ",
							" Remarks None ",
							" SYS_MQTT_CALLBACK Function ",
							" C int32_t SYS_MQTT_CALLBACK(SYS_MQTT_EVENT_TYPE eEventType void *data uint16_t len void* cookie); ",
							" Summary Pointer to a MQTT system service callback function ",
							" Description This data type defines a pointer to a Mqtt service callback function thus defining the function signature Callback functions may be registered by mqtt clients of the Mqtt service via the SYS_MQTT_Connect call ",
							" Precondition Is a part of the Mqtt service Setup using the SYS_MQTT_Connect function ",
							" Parameters Param Description eEventType - event (SYS_MQTT_EVENT_TYPE) Message Received/ Got Disconnected data - Data (if any) related to the Event len - Length of the Data received cookie - A context value returned untouched to the client when the callback occurs It can be used to identify the instance of the client who registered the callback ",
							" Returns None ",
							" Example void MqttSrvcCallback(SYS_MQTT_EVENT_TYPE event void *data uint16_t len void* cookie ) { switch(event) { case SYS_MQTT_EVENT_MSG_RCVD: { SYS_MQTT_PublishConfig *psMsg = (SYS_MQTT_PublishConfig *)data; psMsg- message[psMsg- messageLength] = 0; psMsg- topicName[psMsg- topicLength] = 0; SYS_CONSOLE_PRINT(\" nMqttCallback(): Msg received on Topic: %s ; Msg: %s r n\" psMsg- topicName psMsg- message); break; } case SYS_MQTT_EVENT_MSG_DISCONNECT: { SYS_CONSOLE_PRINT(\"CloudSrvcCallback(): MQTT DOWN\"); break; } } } ",
							" SYS_MQTT_Deinitialize Function ",
							" C int32_t SYS_MQTT_Deinitialize() ",
							" Summary Deinitialization of data structures of the MQTT service ",
							" Description This function is used for freeing the allocated data structures for the MQTT service ",
							" Example SYS_MQTT_Deinitialize() ",
							" Remarks None ",
							" SYS_MQTT_Initialize Function ",
							" C int32_t SYS_MQTT_Initialize() ",
							" Summary Returns success/ failure for initialization of data structures of the MQTT service ",
							" Description This function is used for initializing the data structures of the MQTT service and is called from within the System Task ",
							" Returns SYS_NET_SUCCESS - Indicates the data structures were initialized successfully SYS_NET_FAILURE - Indicates that it failed to initialize the data structures ",
							" Example if( SYS_MQTT_Initialize() == SYS_MQTT_SUCCESS) { } ",
							" Remarks If the MQTT system service is enabled using MHC then auto generated code will take care of its initialization ",
							" SYS_MQTT_Connect Function ",
							" C SYS_MODULE_OBJSYS_MODULE_OBJ* SYS_MQTT_Connect(SYS_MQTT_Config *cfg SYS_MQTT_CALLBACK fn MqttFn void *cookie); ",
							" Summary Connects to the configured MQTT Broker ",
							" Description This function opens a new instance and connects to the configured MQTT Broker ",
							" Parameters cfg - Configuration based on which the Cloud Service needs to Open MqttFn - Function pointer to the Callback to be called in case of an event cookie - Cookie passed as one of the params in the Callback for the user to identify the service instance ",
							" Returns If successful returns a valid handle to an object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MQTT_Config g_sMqttSrvcCfg; SYS_MODULE_OBJ g_MqttSrvcHandle; memset( g_sMqttSrvcCfg 0 sizeof(g_sMqttSrvcCfg)); g_sMattSrvcCfg configBitmask |= SYS_MQTT_CONFIG_MASK_MQTT; strcpy(g_sMqttSrvcCfg mqttConfig brokerConfig brokerName \"test mosquitto org\" strlen(\"test mosquitto org\")); g_sMqttSrvcCfg mqttConfig brokerConfig serverPort = 1883; strcpy(g_sMqttSrvcCfg mqttConfig brokerConfig clientId \"pic32mzw1\" strlen(\"pic32maw1\")); g_sMqttSrvcCfg mqttConfig brokerConfig autoConnect = 1; g_sMqttSrvcCfg mqttConfig brokerConfig tlsEnabled = 0; g_sMqttSrvcCfg mqttConfig subscribeCount = 1; strcpy(g_sMqttSrvcCfg mqttConfig subscribeConfig[0] topicName \"house/temperature/first_floor/kitchen\" strlen(\"house/temperature/first_floor/kitchen\")); g_sMqttSrvcCfg mqttConfig subscribeConfig[0] qos = 1; g_MqttSrvcHandle = SYS_MQTT_Connect( g_sMqttSrvcCfg MqttSrvcCallback 0); if (g_MqttSrvcHandle == SYS_MODULE_OBJ_INVALID) { // Handle error } ",
							" Remarks This routine should be called only once when the user is configuring the Mqtt service ",
							" SYS_MQTT_Disconnect Function ",
							" C void SYS_MQTT_Disconnect(SYS_MODULE_OBJ obj) ",
							" Summary Disconnects from the MQTT Server ",
							" Description This function is used for disconnecting from the MQTT Server ",
							" Precondition SYS_MQTT_Connect should have been called ",
							" Parameters obj - SYS_MQTT object handle returned from SYS_MQTT_Connect ",
							" Returns None ",
							" Example // Handle \"objSysMqtt\" value must have been returned from SYS_MQTT_Connect SYS_MQTT_Disconnect(objSysMqtt); ",
							" Remarks None ",
							" SYS_MQTT_GetStatus Function ",
							" C SYS_MQTT_STATUS SYS_MQTT_GetStatus ( SYS_MODULE_OBJ object ) ",
							" Summary Returns System MQTT instance status ",
							" Description This function returns the current status of the System MQTT instance ",
							" Precondition SYS_MQTT_Connect should have been called before calling this function ",
							" Parameters Param Description object SYS MQTT object handle returned from SYS_MQTT_Connect ",
							" Returns SYS_MQTT_STATUS ",
							" Example // Handle \"objSysMqtt\" value must have been returned from SYS_MQTT_Connect if (SYS_MQTT_GetStatus (objSysMqtt) == SYS_MQTT_STATUS_WAIT_FOR_MQTT_CONACK) { // MQTT system service is initialized and Waiting for the Connect Ack // from the Broker for the Connect Packet sent by DUT to it } ",
							" Remarks None ",
							" SYS_MQTT_Publish Function ",
							" C int32_t SYS_MQTT_Publish(SYS_MODULE_OBJ obj SYS_MQTT_PublishTopicCfg *psPubCfg char *message uint16_t message_len); ",
							" Summary Returns success/ failure for the publishing of message on a topic by the user ",
							" Description This function is used for Publishing a message on a Topic ",
							" Precondition SYS_MQTT_Connect should have been called before calling this function ",
							" Parameters Param Description obj SYS MQTT object handle returned from SYS_MQTT_Connect psPubCfg - valid pointer to the Topic details on which to Publish message - Message to be published message_len Message length ",
							" Returns SYS_MQTT_SUCCESS - Indicates that the Request was catered to successfully SYS_MQTT_FAILURE - Indicates that the Request failed ",
							" Example SYS_MQTT_PublishTopicCfg sTopicCfg; memset( sTopicCfg 0 sizeof(sTopicCfg)); sTopicCfg qos = 1; sTopicCfg retain = 1; strcpy(sTopicCfg topicName \"house/temperature/first_floor/kitchen\"); sTopicCfg topicLength = strlen(\"house/temperature/first_floor/kitchen\"); // Handle \"objSysMqtt\" value must have been returned from SYS_MQTT_Connect if( SYS_MQTT_Publish(objSysMqtt sPublishCfg \"80 17\" strlen(\"80 17\")) == SYS_MQTT_SUCCESS) { } ",
							" SYS_MQTT_Subscribe Function ",
							" C int32_t SYS_MQTT_Subscribe(SYS_MODULE_OBJ obj SYS_MQTT_SubscribeConfig *subConfig); ",
							" Summary Returns success/ failure for the subscribing to a Topic by the user ",
							" Description This function is used for subscribing to a Topic ",
							" Precondition SYS_MQTT_Connect should have been called before calling this function ",
							" Parameters Param Description obj SYS MQTT object handle returned from SYS_MQTT_Connect subConfig - valid pointer to the Topic details on which to Subscribe ",
							" Returns SYS_MQTT_SUCCESS - Indicates that the Request was catered to successfully SYS_MQTT_FAILURE - Indicates that the Request failed ",
							" Example SYS_MQTT_SubscribeConfig sSubscribeCfg; memset( sSubscribeCfg 0 sizeof(sSubscribeCfg)); sSubscribeCfg qos = 1; strcpy(sSubscribeCfg topicName \"house/temperature/first_floor/kitchen\"); // Handle \"objSysMqtt\" value must have been returned from SYS_MQTT_Connect if( SYS_MQTT_Subscribe(objSysMqtt sSubscribeCfg) == SYS_MQTT_SUCCESS) { } ",
							" SYS_MQTT_Unsubscribe Function ",
							" C int32_t SYS_MQTT_Unsubscribe(SYS_MODULE_OBJ obj char *subTopic); ",
							" Summary Returns success/ failure for the unsubscribing to a Topic by the user ",
							" Description This function is used for Unsubscribing from a Topic ",
							" Precondition SYS_MQTT_Connect should have been called before calling this function ",
							" Parameters Param Description obj SYS MQTT object handle returned from SYS_MQTT_Connect subtopic - Topic from which to unsubscribe ",
							" Returns SYS_MQTT_SUCCESS - Indicates that the Request was catered to successfully SYS_MQTT_FAILURE - Indicates that the Request failed ",
							" Example // Handle \"objSysMqtt\" value must have been returned from SYS_MQTT_Connect if( SYS_MQTT_Unsubscribe(objSysMqtt \"house/temperature/first_floor/kitchen\") == SYS_MQTT_SUCCESS) { } ",
							" SYS_MQTT_Task Function ",
							" C void SYS_MQTT_Task(SYS_MODULE_OBJ obj) ",
							" Summary Executes the MQTT Service State Machine ",
							" Description This function ensures that the MQTT service is able to execute its state machine to process any messages and invoke the user callback for any events ",
							" Precondition SYS_MQTT_Connect should have been called before calling this function ",
							" Parameters Param Description obj SYS MQTT object handle returned from SYS_MQTT_Connect ",
							" Returns None ",
							" Example // Handle \"objSysMqtt\" value must have been returned from SYS_MQTT_Connect while(1) { SYS_MQTT_Task(objSysMqtt); } ",
							" MQTT System Service Developer's Guide The purpose of this document is to explain the MQTT system service design to enable the developer to make changes in the service code as per his/ her requirements if the need be ",
							" Overview MQTT system service Library provides an application programming interface (API) to manage MQTT Protocol functionalities The MQTT system service uses the third party software Paho APIs for achieving these functionalities It supports key features like client mode for MQTT connectivity TLS for MQTT connection Self-Healing etc Stack Though the application developer is free to use the third party software directly to manage the MQTT functionalities the use of MQTT system service eases the work of the developer by reducing the state machine that the application needs to maintain while also reducing the amount of bookkeeping that otherwise is needed ",
							" Detailed Design MQTT system service is a background service that runs in the context of the application task The idea of the MQTT system service is to reduce the code size for the application and simplifying the state machine that the application may need to maintain by abstracting out the complexity in the system service The system service achieves this by maintaining a state machine of its own and any bookkeeping that may be needed The MQTT system service supports only client mode Also the service supports secured connections for its MQTT connection with the server The MQTT system service also supports Self-Healing or ‘Auto-Reconnect’ In case there is an interruption in the connection due to the underlying lower layer or when the peer disconnects the service tries to reconnect again without making the application to bother about retriggering the connection ",
							" State Machine The various states of the MQTT system service are of the enum type SYS_MQTT_STATUS The application is expected to call SYS_MQTT_Task() periodically from its own task context This function ensures that the MQTT system service state machine receives sufficient execution cycles to process pending packets in the network stack ",
							" MQTT Client State Machine The MQTT system service runs a finite state machine with the following states: SYS_MQTT_STATUS_IDLE : Initial State of the MQTT system service at the initialization SYS_MQTT_STATUS_LOWER_LAYER_DOWN : State the MQTT system service enters after initialization In this state the MQTT system service opens the TCP socket using NET system service without bothering if the lower layer is UP or DOWN This offloads the application’s burden to poll the link before communicating over the network SYS_MQTT_STATUS_SOCK_CLIENT_CONNECTING : In this state the service opens a socket to connect to the MQTT server using NET system service and waits for the connection to get established SYS_MQTT_STATUS_SOCK_CONNECTED : TCP connection between the client the MQTT server established; client triggers MQTT ‘Connect’ to the server via the Paho APIs SYS_MQTT_STATUS_SOCK_OPEN_FAILED : Opening the Socket failed Failure is conveyed to the application via the callback registered with the service SYS_MQTT_STATUS_MQTT_CONNECTED : Client connected to the MQTT server; Connection status is conveyed to the application via the registered callback In this state the service is waiting to receive data on topic(s) SYS_MQTT_STATUS_MQTT_DISCONNECTING : Client comes into this state whenever there is either of the following: A failure to connect to the server (tcp or mqtt connection) or Timeout occurs on not receiving expected response or Failure in case of publishing a message or subscribing to a topic In this state the client reinitializes the data w r t subscriptions topics Paho API to connect to MQTT server failed SYS_MQTT_STATUS_MQTT_DISCONNECTED : Client disconnected from the server ‘Disconnection’ is conveyed to the application via the registered callback SYS_MQTT_STATUS_WAIT_FOR_MQTT_CONACK : Client waits for the reply ‘CONACK’ from the MQTT server in response to his ‘CONNECT’ message for SYS_MQTT_PERIOIDC_TIMEOUT seconds SYS_MQTT_STATUS_WAIT_FOR_MQTT_SUBACK : Client waits for the reply ‘SUBACK’ from the MQTT server in response to his ‘SUBSCRIBE’ message for SYS_MQTT_PERIOIDC_TIMEOUT seconds SYS_MQTT_STATUS_WAIT_FOR_MQTT_PUBACK : Client waits for the reply ‘PUBACK’ from the MQTT server in response to his ‘PUBLISH’ message in case it was sent with Qos as 1 or 2 for SYS_MQTT_PERIOIDC_TIMEOUT seconds SYS_MQTT_STATUS_WAIT_FOR_MQTT_UNSUBACK : Client waits for the reply ‘UNSUBACK’ from the MQTT server in response to his ‘UNSUBSCRIBE’ message for SYS_MQTT_PERIOIDC_TIMEOUT seconds StateMachine The above state machine has been implemented in the function SYS_MQTT_Paho_Task() The statme machine figure has been broken into two so as to make it simpler to understand and hence both the above state machine figures should be seen in conjection In case the user wants to add or remove a state or modify the action to be done in an existing state (for instance adding a timer for a time-bound result) one would need to modify the function SYS_MQTT_Paho_Task() along with the enum SYS_MQTT_STATUS  ",
							" Number of Subscription Topics Supported The number of subscription topics supported by MQTT system service currently is 2 **The same can be increased by changing the value of the macro *SYS_MQTT_SUB_MAX_TOPICS ***Also note that the underlying third party software Paho supports 5 subscription topics so if the developer needs to use more than 5 topics he/ she will need to make changes in the Paho code ( MAX_MESSAGE_HANDLERS ) too ",
							" Timeperiod for ACK The number of seconds the MQTT system service will wait for the ACK to come – CONACK or SUBACK or PUBACK or UNSUBACK is currently 5 seconds The developer can increase or decrease this time by modifying the value of SYS_MQTT_PERIOIDC_TIMEOUT ",
							" External APIs ",
							" SYS_MQTT_Connect () Description: The API is used for connecting an MQTT client to the server The user needs to register a callback function via this API The registered callback lets the user know the operational status change or when data is received on the topic subscribed to One of the advantages of this API is that the user can call this API without bothering about the operational state of the underlying layers and the service shall take care of all the complexity in such cases resized1_SYS_MQTT_Connect ",
							" SYS_MQTT_Disconnect () Description: The API is used for disconnecting the MQTT client from the server resized_SYS_MQTT_Disconnect ",
							" SYS_MQTT_Publish () Description: The API is used for publishing a message onto a topic resized_SYS_MQTT_Publish ",
							" SYS_MQTT_Subscribe () Description: The API is used for subscribing to a topic resized_SYS_MQTT_Subscribe ",
							" SYS_MQTT_Unsubscribe () Description: The API is used for unsubscribing from a topic resized_SYS_MQTT_Unsubscribe ",
							" Handling of the messages received for a Topic resized_ReceiveMsgOnTopic ",
							" Handling of KeepAlive messages after the MQTT connection is UP resized1_KeepAlive ",
							" SYS_MQTT_Task () Description: This API is used for smooth functioning of the state machine of the MQTT system service** ** The application needs to call this API periodically Also this API takes as parameter the handle returned when we connect to server via the SYS_MQTT_Connect() call ",
							" SYS_MQTT_Initialize ()/ SYS_MQTT_Deinitialize () Description: These functions are used for initializing/ deinitializing the data structures of the MQTT system service The SYS_MQTT_Initialize() function is called from within the System Task Users can modify these functions in case they want to take some additional actions during the initialization of the service ",
							" CLI Commands The details of the cli commands supported by MQTT system service can be found under MQTT System Service Usage The CLI commands are implemented using the function SysMqtt_Command_Process()  The users can modify any of the commands – configuration or get as per their needs by modifying the above function ",
							" Code location The base code for the MQTT system service can be found in the wireless_system_pic32mzw1_wfi32e01 system mqtt The same shall be copied to the following location after the code for the application is generated – my_application firmware src config pic32mz_w1_curiosity system mqtt The code has 4 files: Header file: sys_mqtt h and sys_paho_mqtt h Source file: src/sys_mqtt c and src/sys_paho_mqtt c Since the above files could see modifications across releases hence the users would need to take care of merging the changes they did in these files with the ones which were done in the new release by Microchip Team For this the user needs to take care of this while generating the code via the MHC: MhcMergeStrategy While generating the code the user should use the Merge Strategy as “USER_ALL” and press “Generate” In case there are changes done by user in any of the files the MHC shall prompt the user about it: resized_MhcMergeWindow The user can merge his changes with the the latest changes done in the services using the above window ",
							" Reference S No Name 1 MQTT system service Usage 2 MQTT system service Interface 3 NET system service Interface ",
							" Net System Service Net System Service Library provides an application programming interface (API) to manage TCPIP Networking functionalities The Net System Service uses the NetPres APIs for achieving these functionalities Key Features: Supports Client/ Server Mode for IP Network Connectivity Supports TCP and UDP Protocols of IP Supports TLS for TCP Connection Supports Self Healing that is if the connection for some reason breaks the service shall take care of reconnecting the same internally The Net System Service provides simple API's to enable network stack functionalities Multiple clients can request the Net system service functionalities like tcp/udp connection request tcp/udp disconnect request sending and receiving data etc ",
							" Net System Service Configuration The NET System Service library should be configured through the MHC When user selects the NET System Service library all the required dependencies components are added automatically in the MHC configuration In the NET System Service library user can select the mode as Client or Server and make required changes for the selected mode The following figure shows the MHC configuration window for configuring the NET System Service and a brief description of various configuration options Open the MHC 3 Drag the Net Service Module into the Active components from the Available components Net_service_MHC Configure the various parameters resized_Net_service_config Configure the Supported Interface - 'WIFI_ONLY' (Wifi Only) or 'WIFI_ETHERNET' (Wifi and Ethernet Both) or 'ETHERNET_ONLY (Ethernet Only)' On choosing WIFI_ETHERNET or ETHERNET_ONLY the MHC will add EthMAC MIIM and LAM8740 Components Net_service_SuppIntf The User needs to attach the EthMAC to the NetConfig (in System Component Window) via the MAC parameter in Instance 1 like below: Net_service_netconfig Configure the Number of Sockets Supported - 2 to 8 default sockets being 2 Net_service_SuppSocks Debug - Enabled by default - has 'CLI Commands' and 'Debug Logs' as sub parameters Net_service_config_debug a Enable CLI Commands - This is enabled by default This can be used by the user to give commands on the CLI to open/ close/ send message on a socket b Enable Debug Logs in case more prints are required for debugging By Default the parameter value is 'False' Note: In case the user enables debug logs user needs to manually add the 'App Debug Service' component from Wireless- System Service- App Debug Service User can configure 2 instances of a Net Socket By default only the first one is enabled Instance 0: Configure the Network Interface as Wifi or Ethernet Note that Ethernet as an interface can only be chosen if the 'Supported Intefaces' parameter is WIFI_ETHERNET Net_service_Inst0_Intf Configure the IP Protocol as either TCP or UDP Net_service_config_ipprot Configure the Mode as either Client or Server Net_service_config_mode Enable/ Disable \"Auto Connect\" as per your requirement This parameter when enabled ensures that if the NET Connection disconnects the service internally tries to reconnect By Default the parameter value is 'True' Enable/ Disable \"Enable TLS\" in case the connection needs to be secured This parameter is valid only in case of 'Client' mode Please note that in case this parameter is Enabled users need to configure the WolfSSL related configuration on their own Also this parameter is valid only for TCP Connections By Default the parameter value is 'False' Note: In case the TLS is enabled the User needs to update the component 'Presentation Layer' with the CA Certificate format location name and size Other parameters can be updated as per the User's requirements \"Enable SNI\" - Server Name Indication if TRUE enables a client device to specify the domain name it is trying to reach in the first step of the TLS handshake By Default the parameter value is 'False' Note: In case the SNI is enabled the Server Name is taken as the Domain Name \"Enable ALPN\" - Application-Layer Protocol Negotiation (ALPN) is a TLS extension that allows the application layer to negotiate which protocol should be performed over a secure connection in a manner that avoids additional round trips and which is independent of the application-layer protocols By Default the parameter value is 'False' Net_service_tls_details Configure the various parameters of Presentation Layer if TLS enabled presentation_layer Server Port - 1-65535 This is a mandatory parameter In case Mode is selected as Client Server port should be set to the port number of the server with which the device will connect In case mode is selected as Server Server port should be set to the port number at which the server will start Host Name/ IP Address: Can be a Host Name or an IP Address By Default the parameter value is '192 168 1 1' Instance 1 - User can enable this to give a configuration for another socket Also once the user gives this config SYS_NET_Open() API will return error if it is passed NULL as config since now more than one instance is defined in the MHC To use the device certificates stored in ATECC608A-TNGTLS enable the \"Trust Go client certificate\" option under the net configurations TNGTLS_ClientCert All of the required files are automatically added into the MPLAB X IDE project by the MHC when the Net Service is selected for use ",
							" Net System Service Usage ",
							" Description The NET System Service provides simple APIs to enable Server or Client Connectivity for either TCP or UDP The User need not take care of intermediate states of a TCPIP Connection as the Service internally takes care of that User is not required to have Security domain knowledge to establish a secured connection via the application using NET System Service library ",
							" Command Line: User can follow below commands for NET System Service: sysnethelp NET System Service help command which displays the supported CLI commands resized_sysnethelp_cli sysnet open Command for Reconfiguring an already open instance of Net System Service sysnetopen_cli sysnet close Command to close the instance of Net System Service sysnetclose_cli sysnet send Command to send message on the network connection established by the instance of Net System Service sysnetsend_cli sysnet get info Command for knowing the Current Information for all the Instances of Net System Service sysnetgetinfo_cli ",
							" Abstraction Model The NET System Service library provides an abstraction to the NetPres/ TCPIP APIs to provide following functionalities Connectivity for TCP Client Connectivity for TCP Server Connectivity for UDP Client Connectivity for UDP Server Self Healing Reduce code user has to write Reduce time to develop and maintain The following diagram depicts the Net System Service abstraction model NetService_abstract ",
							" How The Library Works By default MHC generated code provides all the functionalities to enable Client or Server mode applicatation with TCP or UDP as the IP Protocol User needs to configure the required Client or Server mode configuration using MHC User needs to call the SYS_NET_Open() API with a valid callback to open an instance of the Client/ Server configured in the MHC NetOpen The User Application is expected to call SYS_NET_Task() API periodically as this API ensures that the Net System service is able to execute its state machine to process any messages and invoke the user callback for any events NetTask The User Application can call SYS_NET_CtrlMsg() API in case it wants to disconnect the opened connection or to reconnect using different configuration NetCtrlMsg ",
							" Net System Service Interface ",
							" Data Types and Constants Summary Name Description SYS_NET_INTF_WIFI Net Socket Intf - Wifi SYS_NET_INTF_ETHERNET Net Socket Intf - Ethernet SYS_NET_MODE_CLIENT Net Socket Mode - Client SYS_NET_MODE_SERVER Net Socket Mode - Server SYS_NET_MAX_HOSTNAME_LEN Max Host Name Length SYS_NET_IP_PROT_UDP Ip Protocol Mode - UDP SYS_NET_IP_PROT_TCP Ip Protocol Mode - TCP SYS_NET_MAX_NUM_OF_SOCKETS Number of Instances Supported by the NET System Service SYS_NET_DEFAULT_TLS_ENABLE Default Values for TLS - False SYS_NET_DEFAULT_AUTO_RECONNECT Default Values for Auto Reconnect - True SYS_NET_DEFAULT_NET_INTF Default Values for Interface - 0 (Wifi) NET_CFG AppDebug Flow for the Logs - Configuration NET_DATA AppDebug Flow for the Logs - Data SYS_NET_Config Used for passing on the configuration related to the Net Socket that needs SYS_NET_STATUS Identifies the current status of the Sys Net Instance SYS_NET_EVENT Identifies the event type for which the User Callback is called SYS_NET_CTRL_MSG Identifies the control message for which the User has called the SYS_NET_CtrlMsg() SYS_NET_RESULT Identifies the return values for the Sys Net APIs ",
							" Initialization functions Summary Name Description SYS_NET_Initialize Returns success/ failure for initialization of data structures of the NET service SYS_NET_Deinitialize Deinitialization of data structures of the NET service ",
							" Status functions Summary Name Description SYS_NET_GetStatus Returns System NET instance status ",
							" Setup functions Summary Name Description SYS_NET_Open Opens a new NET System Service instance SYS_NET_Close Deinitializes the specific instance of the NET System service SYS_NET_Task Executes the SYS NET service state machine for the instance SYS_NET_CtrlMsg Returns success/ failure for the disconnect/ reconnect operation asked by the user SYS_NET_SetConfigParam Returns success on setting a configuration parameter for Net System Service ",
							" Data Exchange functions Summary Name Description SYS_NET_SendMsg Returns No of Bytes sent to peer using the System NET instance SYS_NET_RecvMsg Returns No of Bytes received from peer using the System NET instance SYS_NET_CALLBACK Pointer to a Net system service callback function ",
							" SYS_NET_DEFAULT_AUTO_RECONNECT Macro ",
							" C #define SYS_NET_DEFAULT_AUTO_RECONNECT 1 // Auto Reconnect Enabled by default ",
							" Summary Default Values for Auto Reconnect - True ",
							" Remarks None ",
							" SYS_NET_DEFAULT_NET_INTF Macro ",
							" C #define SYS_NET_DEFAULT_NET_INTF SYS_NET_INTF_WIFI // Interface 0 by default ",
							" Summary Default Values for Interface - 0 (Wifi) ",
							" Remarks None ",
							" SYS_NET_DEFAULT_TLS_ENABLE Macro ",
							" C #define SYS_NET_DEFAULT_TLS_ENABLE 0 // TLS Disabled by default ",
							" Summary Default Values for TLS - False ",
							" Remarks None ",
							" SYS_NET_INTF_ETHERNET Macro ",
							" C #define SYS_NET_INTF_ETHERNET 1 // Ethernet Intf Value ",
							" Summary Net Socket Intf - Ethernet ",
							" Remarks None ",
							" SYS_NET_INTF_WIFI Macro ",
							" C #define SYS_NET_INTF_WIFI 0 // Wifi Intf Value ",
							" Summary Net Socket Intf - Wifi ",
							" Remarks None ",
							" SYS_NET_IP_PROT_TCP Macro ",
							" C #define SYS_NET_IP_PROT_TCP 1 // TCP - Ip Protocol Value ",
							" Summary Ip Protocol Mode - TCP ",
							" Remarks None ",
							" SYS_NET_MAX_HOSTNAME_LEN Macro ",
							" C #define SYS_NET_MAX_HOSTNAME_LEN 256 // Max Host Name Length ",
							" Summary Max Host Name Length ",
							" Remarks None ",
							" SYS_NET_IP_PROT_UDP Macro ",
							" C #define SYS_NET_IP_PROT_UDP 0 // UDP - Ip Protocol Value ",
							" Summary Ip Protocol Mode - UDP ",
							" Remarks None ",
							" SYS_NET_MAX_NUM_OF_SOCKETS Macro ",
							" C #define SYS_NET_MAX_NUM_OF_SOCKETS SYS_NET_SUPP_NUM_OF_SOCKS // umber of Instances Supported by the NET System Service ",
							" Summary Number of Instances Supported by the NET System Service ",
							" Remarks None ",
							" SYS_NET_MODE_CLIENT Macro ",
							" C #define SYS_NET_MODE_CLIENT 0 // Client Mode Value ",
							" Summary Net Socket Mode - Client ",
							" Remarks None ",
							" SYS_NET_MODE_SERVER Macro ",
							" C #define SYS_NET_MODE_SERVER 1 // Server Mode Value ",
							" Summary Net Socket Mode - Server ",
							" Remarks None ",
							" NET_DATA Macro ",
							" C #define NET_DATA 0x2 // App Debug Print Flows - DATA ",
							" Summary AppDebug Flow for the Logs - Data ",
							" Remarks None ",
							" NET_CFG Macro ",
							" C #define NET_CFG 0x1 // App Debug Print Flows - CFG ",
							" Summary AppDebug Flow for the Logs - Configuration ",
							" Remarks None ",
							" SYS_NET_EVENT Enum ",
							" C typedef enum { // NET Socket connected to Peer SYS_NET_EVNT_CONNECTED = 0 // NET Socket disconnected SYS_NET_EVNT_DISCONNECTED // Received Data on NET Socket connected to Peer SYS_NET_EVNT_RCVD_DATA // SSL Negotiation Failed SYS_NET_EVNT_SSL_FAILED // DNS Resolve Failed SYS_NET_EVNT_DNS_RESOLVE_FAILED // Socket Open Failed SYS_NET_EVNT_SOCK_OPEN_FAILED // Received only in Connected State - Lower Layer Down SYS_NET_EVNT_LL_INTF_DOWN // Received only in Connected State - Lower Layer Up SYS_NET_EVNT_LL_INTF_UP // TCP Server is awaiting connection SYS_NET_EVNT_SERVER_AWAITING_CONNECTION } SYS_NET_EVENT; ",
							" Summary Identifies the event type for which the User Callback is called ",
							" Remarks None ",
							" SYS_NET_RESULT Enum ",
							" C typedef enum { // Success SYS_NET_SUCCESS = 0 // Failure SYS_NET_FAILURE = -1 // Sys NET Service Down SYS_NET_SERVICE_DOWN = -2 // Enough space not available in the transmit buffer to send the message Application should try again later SYS_NET_PUT_NOT_READY = -3 // Sys NET No Data Available for receiving SYS_NET_GET_NOT_READY = -4 // Sys NET Semaphore Operation of Take/ Release Failed SYS_NET_SEM_OPERATION_FAILURE = -5 // Sys NET Invalid Handle SYS_NET_INVALID_HANDLE = -6 } SYS_NET_RESULT; ",
							" Summary Identifies the return values for the Sys Net APIs ",
							" Remarks None ",
							" SYS_NET_CTRL_MSG Enum ",
							" C typedef enum { // NET Socket should reconnect to Peer the User is expected to pass pointer to SYS_NET_Config for the configuration of the new Connection SYS_NET_CTRL_MSG_RECONNECT = 0 // NET Socket disconnect request from the user SYS_NET_CTRL_MSG_DISCONNECT } SYS_NET_CTRL_MSG; ",
							" Summary Identifies the control message for which the User has called the SYS_NET_CtrlMsg() ",
							" Remarks None ",
							" SYS_NET_STATUS Enum ",
							" C typedef enum { // Net Instance is Idle/ Not in Use SYS_NET_STATUS_IDLE = 0 // Lower Layer is Down SYS_NET_STATUS_LOWER_LAYER_DOWN // Resolving DNS of NET Server for the Client to connect SYS_NET_STATUS_RESOLVING_DNS // Net Server IP Available for the Client to connect SYS_NET_STATUS_DNS_RESOLVED // Net Server Awaiting Connection SYS_NET_STATUS_SERVER_AWAITING_CONNECTION // Net Client connecting to Server SYS_NET_STATUS_CLIENT_CONNECTING // Net Client Waiting for SNTP Time Stamp SYS_NET_STATUS_WAIT_FOR_SNTP // Net Client Starting TLS Negotiations SYS_NET_STATUS_TLS_NEGOTIATING // Net Instance TLS Negotiation Failed SYS_NET_STATUS_TLS_NEGOTIATION_FAILED // Net Instance connected to the peer SYS_NET_STATUS_CONNECTED // Net Instance Failed to open socket SYS_NET_STATUS_SOCK_OPEN_FAILED // Net Instance Failed to Resolve DNS SYS_NET_STATUS_DNS_RESOLVE_FAILED // Net Instance in disconnected state SYS_NET_STATUS_DISCONNECTED // Net Instance received FIN from peer SYS_NET_STATUS_PEER_SENT_FIN // Net Instance connected to the peer but the lower layer is down SYS_NET_STATUS_CONNECTED_LL_DOWN } SYS_NET_STATUS; ",
							" Summary Identifies the current status of the Sys Net Instance ",
							" Remarks None ",
							" SYS_NET_Config Struct ",
							" C typedef struct { // Net Socket Mode to Open - SYS_NET_MODE_CLIENT(0)/ SYS_NET_MODE_SERVER(1) uint8_t mode; // WiFi or Eth Interface to be used for Opening the socket uint8_t intf; // Net Server Port uint16_t port; // Reconnect in case of disconnection happening - 1(Reconnect Enabled)/ 0(Reconnect Disabled) bool enable_reconnect; // Net Socket with 1(TLS Enabled)/ 0(TLS Disabled) bool enable_tls; // Socket IP Protocol - SYS_NET_IP_PROT_UDP(0) or SYS_NET_IP_PROT_TCP(1) uint8_t ip_prot; // Host Name - could have the server name or IP char host_name[SYS_NET_MAX_HOSTNAME_LEN]; } SYS_NET_Config; ",
							" Summary Used for passing on the configuration related to the Net Socket that needs to be opened via the Sys Net Service ",
							" Remarks None ",
							" SYS_NET_CALLBACK Typedef ",
							" C typedef void (*SYS_NET_CALLBACK)(uint32_t event void *data void* cookie); ",
							" SYS_NET_CALLBACK Function ",
							" C void SYS_NET_CALLBACK (uint32_t event void *data void* cookie) ",
							" Summary Pointer to a Net system service callback function ",
							" Description This data type defines a pointer to a Net service callback function thus defining the function signature Callback functions may be registered by clients of the net service when opening a Net socket via the Initialize call ",
							" Precondition Is a part of the Net service initialization using the SYS_NET_Open function ",
							" Parameters event - An event (SYS_NET_EVENT) for which the callback was called data - Data (if any) related to the Event | Param | Description | |:----- |:----------- | | cookie | A context value returned untouched to the client when the callback occurs ",
							" Returns None ",
							" Example void NetServCallback(uint32_t event void *data void* cookie ) { switch(event) { case SYS_NET_EVNT_CONNECTED: { SYS_CONSOLE_PRINT(\"NetServCallback(): Status UP\"); while(SYS_NET_SendMsg(g_NetServHandle \"hello\" 5) == 0); break; } case SYS_NET_EVNT_DISCONNECTED: { SYS_CONSOLE_PRINT(\"NetServCallback(): Status DOWN\"); break; } case SYS_NET_EVNT_RCVD_DATA: { int32_t len = 32; uint8_t buffer[32] = {0}; len = SYS_NET_RecvMsg(g_NetServHandle buffer len); SYS_CONSOLE_PRINT(\"NetServCallback(): Data Rcvd = %s\" buffer); break; } } } ",
							" Remarks None ",
							" SYS_NET_Initialize Function ",
							" C int32_t SYS_NET_Initialize() ",
							" Summary Returns success/ failure for initialization of data structures of the NET service ",
							" Description This function is used for initializing the data structures of the NET service and is called from within the System Task ",
							" Returns SYS_NET_SUCCESS - Indicates the data structures were initialized successfully SYS_NET_FAILURE - Indicates that it failed to initialize the data structures ",
							" Example if( SYS_NET_Initialize() == SYS_NET_SUCCESS) { } ",
							" Remarks If the Net system service is enabled using MHC then auto generated code will take care of Net System Service initialization ",
							" SYS_NET_Deinitialize Function ",
							" C void SYS_NET_Deinitialize() ",
							" Summary Deinitialization of data structures of the NET service ",
							" Description This function is used for freeing the allocated data structures for the NET service ",
							" Example SYS_NET_Deinitialize() ",
							" Remarks None ",
							" SYS_NET_SetConfigParam Function ",
							" C int32_t SYS_NET_SetConfigParam(SYS_MODULE_OBJ obj uint32_t paramType void *data) ",
							" Summary Returns success on setting a configuration parameter for Net System Service ",
							" Description This function is currently used for enabling/ disabling the Auto Reconnect feature for the Net Socket ",
							" Precondition SYS_NET_Open should have been called ",
							" Parameters obj - SYS NET object handle returned from SYS_NET_Open | Param | Description | |:----- |:----------- | | paramType | Reserved for future use data - 0/ 1 currently used only for enabling/ disabling the auto reconnect feature ",
							" Returns SYS_NET_SUCCESS - Indicates that the Request was catered to successfully ",
							" Example bool auto_reconnect = true; // Handle \"objSysNet\" value must have been returned from SYS_NET_Open if( SYS_NET_SetConfigParam(objSysNet 0 auto_reconnect) == SYS_NET_SUCCESS) { } ",
							" Remarks None ",
							" SYS_NET_Open Function ",
							" C SYS_MODULE_OBJ SYS_NET_Open (SYS_NET_Config *cfg SYS_NET_CALLBACK Net_cb void *cookie) ",
							" Summary Opens a new NET System Service instance ",
							" Description This function opens the instance of the NET System Service ",
							" Parameters cfg - Configuration for which the NET Socket needs to be opened Net_cb - Function pointer to the Callback to be called in case of an event cookie - Cookie passed as one of the params in the Callback which was registered by the user in SYS_NET_Open ##Returns Returns: If successful returns a valid handle to an object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_NET_Config g_NetServCfg; SYS_MODULE_OBJ g_NetServHandle; memset( g_NetServCfg 0 sizeof(g_NetServCfg)); g_NetServCfg mode = SYS_NET_MODE_CLIENT; strcpy(g_NetServCfg host_name APP_HOST_NAME); g_NetServCfg port = APP_HOST_PORT; g_NetServCfg enable_tls = 0; g_NetServCfg ip_prot = SYS_NET_IP_PROT_UDP; g_NetServHandle = SYS_NET_Open( g_NetServCfg NetServCallback 0); if (g_NetServHandle == SYS_MODULE_OBJ_INVALID) { // Handle error } ",
							" Remarks This routine should be called everytime a user wants to open a new NET socket Also in case the user is opening a Client Socket and the under lying network interface is Wifi in AP Mode it is recommended that the call be made only after the STA running the server connects to the AP on the Wifi interface ",
							" SYS_NET_Close Function ",
							" C void SYS_NET_Close ( SYS_MODULE_OBJ object ) ",
							" Summary Deinitializes the specific instance of the NET System service ",
							" Description This function deinitializes the specific module instance disabling its operation Resets all of the internal data structures and fields for the specified instance to the default settings ",
							" Precondition The SYS_NET_Open function should have been called before calling this function ",
							" Parameters Param Description object SYS NET object handle returned from SYS_NET_Open ",
							" Returns None ",
							" Example // Handle \"objSysNet\" value must have been returned from SYS_NET_Open SYS_NET_Close (objSysNet); ",
							" Remarks Once the Open operation has been called the Close operation must be called before the Open operation can be called again ",
							" SYS_NET_CtrlMsg Function ",
							" C int32_t SYS_NET_CtrlMsg(SYS_MODULE_OBJ obj SYS_NET_CTRL_MSG msg_type void *data uint16_t len) ",
							" Summary Returns success/ failure for the disconnect/ reconnect operation asked by the user ",
							" Description This function is used for disconnecting or reconnecting to the peer ",
							" Precondition SYS_NET_Open should have been called ",
							" Parameters obj - SYS NET object handle returned from SYS_NET_Open | Param | Description | |:----- |:----------- | | msg_type | valid Msg Type SYS_NET_CTRL_MSG | | data - valid data buffer pointer based on the Msg Type | NULL for DISCONNECT Pointer to SYS_NET_Config for RECONNECT len - length of the data buffer the pointer is pointing to ",
							" Returns SYS_NET_SUCCESS - Indicates that the Request was catered to successfully SYS_NET_FAILURE - Indicates that the Request failed ",
							" Example // Handle \"objSysNet\" value must have been returned from SYS_NET_Open if( SYS_NET_CtrlMsg(objSysNet SYS_NET_CTRL_MSG_DISCONNECT NULL 0) == SYS_NET_SUCCESS) { } ",
							" Remarks None ",
							" SYS_NET_GetStatus Function ",
							" C SYS_NET_STATUS SYS_NET_GetStatus ( SYS_MODULE_OBJ object ) ",
							" Summary Returns System NET instance status ",
							" Description This function returns the current status of the System NET instance ",
							" Precondition SYS_NET_Open should have been called before calling this function ",
							" Parameters Param Description object SYS NET object handle returned from SYS_NET_Open ",
							" Returns SYS_NET_STATUS ",
							" Example // Handle \"objSysNet\" value must have been returned from SYS_NET_Open if (SYS_NET_GetStatus (objSysNet) == SYS_NET_STATUS_SERVER_AWAITING_CONNECTION) { // NET system service is initialized and the NET server is ready to accept new connection } ",
							" Remarks None ",
							" SYS_NET_RecvMsg Function ",
							" C int32_t SYS_NET_RecvMsg(SYS_MODULE_OBJ obj void *data uint16_t len) ",
							" Summary Returns No of Bytes received from peer using the System NET instance ",
							" Description This function returns the number of bytes received from the peer ",
							" Precondition SYS_NET_Open should have been called ",
							" Parameters obj - SYS NET object handle returned from SYS_NET_Open data - valid data buffer pointer len - length of the data to be transmitted ",
							" Returns SYS_NET_SERVICE_DOWN - Indicates that the System NET instance is not connected to the peer SYS_NET_GET_NOT_READY - Indicates that the System NET instance No Data to GET Positive Non-Zero - Indicates the number of bytes received from the peer which may be less than the \"len\" of the buffer passed as the param ",
							" Example // Handle \"objSysNet\" value must have been returned from SYS_NET_Open int32_t len = 32; uint8_t buffer[32] = {0}; len = SYS_NET_RecvMsg(objSysNet buffer len); if(len 0) { } ",
							" Remarks None ",
							" SYS_NET_SendMsg Function ",
							" C int32_t SYS_NET_SendMsg(SYS_MODULE_OBJ obj uint8_t *buffer uint16_t len) ",
							" Summary Returns No of Bytes sent to peer using the System NET instance ",
							" Description This function returns the number of bytes transmitted to the peer ",
							" Precondition SYS_NET_Open should have been called ",
							" Parameters object - SYS NET object handle returned from SYS_NET_Open data - valid data buffer pointer len - length of the data to be transmitted ",
							" Returns SYS_NET_SERVICE_DOWN - Indicates that the System NET instance is not connected to the peer SYS_NET_PUT_NOT_READY - Indicates that the System NET instance Put is NOT ready SYS_NET_PUT_BUFFER_NOT_ENOUGH - Indicates that the System NET instance cannot transmit as the available buffer is less than the bytes to be transmitted Positive Non-Zero - Indicates the number of bytes transmitted to the peer ",
							" Example // Handle \"objSysNet\" value must have been returned from SYS_NET_Open while(SYS_NET_SendMsg(objSysNet \"hello\" 5) = 0); ",
							" Remarks None ",
							" SYS_NET_Task Function ",
							" C void SYS_NET_Task(SYS_MODULE_OBJ obj) ",
							" Summary Executes the SYS NET service state machine for the instance ",
							" Description This function ensures that the Net system service is able to execute its state machine to process any messages and invoke the user callback for any events ",
							" Precondition SYS_NET_Open should have been called before calling this function ",
							" Parameters Param Description obj SYS NET object handle returned from SYS_NET_Open ",
							" Returns None ",
							" Example // Handle \"objSysNet\" value must have been returned from SYS_NET_Open while(1) { SYS_NET_Task(objSysNet); } ",
							" Net System Service Developer's Guide The purpose of this document is to explain the NET system service design to enable the developer to make changes in the service code as per his/ her requirements if the need be ",
							" Overview NET system service Library provides an application programming interface (API) to manage TCP/IP Networking functionalities The NET system service uses the MPLAB Harmony NetPres APIs for achieving these functionalities It supports key features like Client/ Server Mode for IP Network Connectivity TLS for TCP Connection Self-Healing etc Stack Though the application developer is free to use the Harmony NetPres or TCP/ IP Stack APIs directly to manage the TCP/ IP Networking functionalities the use of NET system service eases the work of the developer by reducing the state machine that the application needs to maintain while also reducing the amount of bookkeeping that otherwise is needed ",
							" Detailed Design NET system service is a background service that runs in the context of the application task The idea of the NET system service is to reduce the code size for the application and simplifying the state machine that the application may need to maintain by abstracting out the complexity in the system service The system service achieves this by maintaining a state machine of its own and any bookkeeping that may be needed The NET system service supports two modes – CLIENT - (SYS_NET_MODE_CLIENT Macro) and SERVER - (SYS_NET_MODE_SERVER Macro) for both the transport protocols – TCP - SYS_NET_IP_PROT_TCP Macro) and UDP - (SYS_NET_IP_PROT_UCP Macro) Also the service supports secured connections for TCP The NET system service also supports Self-Healing or ‘Auto-Reconnect’ In case there is an interruption in the connection due to the underlying lower layer or when the peer disconnects the service tries to reconnect again without making the application to bother about retriggering the connection ",
							" State Machine The various states of the NET system service are of the enum type SYS_NET_STATUS The Client and Server have a separate state machine The application is expected to call SYS_NET_Task() periodically from its own task context This function ensures that the NET system service state machine receives sufficient execution cycles to process pending packets in the network stack ",
							" Client State Machine The NET system service runs a finite state machine with the following states in the ‘CLIENT’ mode: SYS_NET_STATUS_IDLE : Initial State of the NET system service at the initialization SYS_NET_STATUS_LOWER_LAYER_DOWN : State the NET system service enters after initialization In this state the NET system service checks for the operational status of the lower layer – Wi-Fi or Ethernet If the link is down the service remains in this state Since this state monitors the link state it offloads the application’s burden to poll the link before communicating over the network SYS_NET_STATUS_RESOLVING_DNS : In this state the service tries to resolve the server DNS to connect to it SYS_NET_STATUS_DNS_RESOLVED : In this state the service has resolved the DNS and opens a socket to connect to the server SYS_NET_STATUS_CLIENT_CONNECTING : In this state the service has resolved the DNS and opens a socket to connect to the server SYS_NET_STATUS_WAIT_FOR_SNTP : Valid for Secured TCP Connection only Service waits for the system to connect to the NTP server and get the time snapshot This is required to validate the peer certificate SYS_NET_STATUS_TLS_NEGOTIATING : Valid for secured TCP connection only TLS negotiation is in progress SYS_NET_STATUS_TLS_NEGOTIATION_FAILED : Valid for secured TCP connection only TLS Negotiation failed Failure conveyed to the application via the callback registered with the service SYS_NET_STATUS_CONNECTED : Client connected to the server; Connection status is conveyed to the application via the callback registered with the service In this state the service is waiting to receive data from the peer SYS_NET_STATUS_SOCK_OPEN_FAILED : Opening the Socket failed Failure is conveyed to the application via the registered callback SYS_NET_STATUS_DNS_RESOLVE_FAILED : DNS for the server is not resolved because the DNS server is unavailable or due to misconfiguration w r t server name Failure is conveyed to the application via the registered callback SYS_NET_STATUS_DISCONNECTED : Client disconnected from the server ‘Disconnection’ is conveyed to the application via the registered callback If the application has enabled ‘Auto-Reconnect ’ the service shall switch to SYS_NET_STATUS_LOWER_LAYER_DOWN state and re-try to connect to the server SYS_NET_STATUS_PEER_SENT_FIN : Valid for TCP Connection only The client received SYN FIN from the peer which is conveyed to the application via the registered callback SYS_NET_STATUS_CONNECTED_LL_DOWN : Lower layer went down while the client is connected to the server This is conveyed to the application but the service shall not take any action on this The service expects the TCP/ IP Stack to take action as per the protocol standards Since the application will be informed about this state it is free to call NET system server API to disconnect the connection with the peer ClientStateMachine The above state machine has been implemented in the function SYS_NET_Client_Task() ",
							" Server State Machine The NET system service runs a finite state machine with the following states valid in ‘SERVER’ mode: SYS_NET_STATUS_IDLE: Initial State of the NET system service at the initialization SYS_NET_STATUS_LOWER_LAYER_DOWN: State the NET system service enters after initialization In this state the NET system service checks for the operational status of the lower layer – Wi-Fi or Ethernet If the link is down the service remains in this state The service shall open the socket if the lower layer link is Up SYS_NET_STATUS_SERVER_AWAITING_CONNECTION: Service waits for a connection from a client SYS_NET_STATUS_WAIT_FOR_SNTP: Valid for Secured TCP Connection only Service waits for the system to connect to the NTP server and get the time snapshot required to validate the peer certificate SYS_NET_STATUS_TLS_NEGOTIATING: Valid for Secured TCP Connection only TLS negotiation is in progress SYS_NET_STATUS_TLS_NEGOTIATION_FAILED: Valid for secured TCP connection only TLS negotiation failed Failure is conveyed to the application via the callback registered with the service SYS_NET_STATUS_CONNECTED: Client connected to the server; Connection Status is conveyed to the application via the callback registered with the service In this state the service is waiting for data from the peer SYS_NET_STATUS_SOCK_OPEN_FAILED: Opening the Socket failed Failure conveyed to the application via the registered callback SYS_NET_STATUS_DISCONNECTED: Client disconnected from the server ‘Disconnection’ is conveyed to the application via the registered callback If the application has enabled ‘Auto-Reconnect’ the service shall open the socket again and switch to SYS_NET_STATUS_SERVER_AWAITING_CONNECTION waiting for the client to reconnect SYS_NET_STATUS_PEER_SENT_FIN: Valid for TCP connection only The client received SYN FIN from the peer which is conveyed to the application via the registered callback SYS_NET_STATUS_CONNECTED_LL_DOWN: Lower Layer went down while the server is connected to the client This is conveyed to the application but the service shall not take any action on this The service expects the TCP/ IP Stack to take action as per the protocol standards Since the application will be informed about this state it is free to call NET system server API to disconnect the connection with the peer ServerStateMachine The above state machine has been implemented in the function SYS_NET_Server_Task() In case the user wants to add or remove a state or modify the action to be done in an existing state (for instance adding a timer for a time-bound result) one would need to modify the function SYS_NET_Server_Task() or and SYS_NET_Client_Task() along with the enum SYS_NET_STATUS ",
							" Number of Sockets Supported The number of sockets supported by NET system service currently is 2 The same can be increased by changing the value of the macro SYS_NET_MAX_NUM_OF_SOCKETS One can also configure the number of sockets via the MHC ",
							" External APIs ",
							" SYS_NET_Open () Description: The API is used for opening the socket for either TCP or UDP in Client or Server Mode The user needs to register a callback function via this API The registered callback lets the user know the operational status change or when data is received on the socket One of the advantages of this API is that the user can open a socket without bothering about the operational state of the underlying layers and the service shall take care of all the complexity in such cases resized_SYS_NET_Open ",
							" SYS_NET_Close () Description: This API is used for closing the socket connection with the peer SYS_NET_Close ",
							" SYS_NET_SendMsg () Description: This API is used for transmitting the data to the peer on this socket connection SYS_NET_SendMsg ",
							" SYS_NET_RecvMsg () Description: This API is used for receiving data sent in by the peer on the socket connection SYS_NET_RecvMsg ",
							" Self-Healing Description: Self-Healing or ‘Auto-Reconnect’ is a feature supported by NET system service where in case there is an interruption in the connection due to the underlying lower layer or when the peer disconnects the service tries to reconnect again without making the application to bother about retriggering the connection Self-Healing ",
							" SYS_NET_Task () Description: This API is used for smooth functioning of the state machine of the NET system service** ** The application needs to call this API periodically Also this API takes as parameter the handle returned when we open the socket via the SYS_NET_Open() call So in case the user opens two sockets he/ she will need to call SYS_NET_Task() perdiocially for each of the socket connections ",
							" SYS_NET_CtrlMsg () Description: This API is used for Reconnecting or Disconnecting an existing connection The user can scale this API for triggering other actions if the need be One of the parameters this API takes is the enum SYS_NET_CTRL_MSG which the user can expand to add on new message type and add a new case in the switch condition of this API to trigger the new action ",
							" SYS_NET_Initialize()/ SYS_NET_Deinitialize() Description: These functions are used for initializing/ deinitializing the data structures of the NET system service The SYS_NET_Initialize() function is called from within the System Task Users can modify these functions in case they want to take some additional actions during the initialization of the service ",
							" SYS_NET_SetConfigParam() Description: The API is currently used for configuring the parameter – ‘auto_reconnect’ after the user has called SYS_NET_Open() The user can modify this API to add other configuration parameters which he/ she may want to change Please note that some of the configuration parameters will come into effect only after the socket reconnects ",
							" CLI Commands The details of the cli commands supported by NET system service can be found under Net System Service Usage The CLI commands are implemented using the function SysNet_Command_Process()  The users can modify any of the commands – configuration or get as per their needs by modifying the above function ",
							" Code location The base code for the NET system service can be found in the wireless_system_pic32mzw1_wfi32e01 system net The same shall be copied to the following location after the code for the application is generated – my_application firmware src config pic32mz_w1_curiosity system net The code has 2 files: Header file: sys_net h Source file: src/sys_net c Since the above files could see modifications across releases hence the users would need to take care of merging the changes they did in these files with the ones which were done in the new release by Microchip Team For this the user needs to take care of this while generating the code via the MHC: MhcMergeStrategy While generating the code the user should use the Merge Strategy as “USER_ALL” and press “Generate” In case there are changes done by user in any of the files the MHC shall prompt the user about it: resized_MhcMergeWindow The user can merge his changes with the the latest changes done in the services using the above window ",
							" Reference S No Name 1 NET system service Usage 2 NET system service Interface ",
							" Wi-Fi System Service Wi-Fi System Service Library provides an application programming interface (API) through which user can request Wi-Fi connectivity functionalities The Wi-Fi System Service use Wi-Fi driver APIs Key Features: Configuration of Station mode(STA) Security Support: Open - No security WPA2 WPAWPA2(Mixed) mode WPA2WPA3(Mixed) WPA3 WPAWPA2 Mixed Enterprise WPA2 Enterprise WPAWPA3 Enterprise WPA3 Enterprise Self Healing if the connection for some reason breaks the service shall take care of reconnecting the same internally Configuration of Soft Access point mode(AP) Security Support: Open - No security WPA2 WPAWPA2(Mixed) WPA2WPA3(Mixed) WPA3 Hidden Access Point(AP) The Wi-Fi System Service provides simple API's to enable Station(STA) or Access Point(AP) functionalities Multiple clients can request the Wi-Fi system service functionalities like connection request disconnect request scan request etc User is not required to have Wi-Fi domain knowledge to developed station(STA) or access point(AP) application using Wi-Fi System Service ",
							" Wi-Fi System Service Usage ",
							" Abstraction Model The Wi-Fi System Service library provides an abstraction to the Wi-Fi driver API's to provide following functionalities Simple APIs to enable/disable STA mode Simple APIs to enable/disable AP mode Self Healing Reduce code user has to write Reduce time to develop and maintain The following diagram depicts the Wi-Fi System Service abstraction model Wifiservice_abstract ",
							" How The Library Works By default MHC generated code provides all the functionalities to enable STA or AP mode application User needs to configure the required STA or AP mode configuration using MHC Seqdig_WiFi_Initialization Multiple clients can register for callbacks to the Wi-Fi System Service Library for getting Wi-Fi connectivity update information Additionally clients can make request to the Wi-Fi System Service Library using SYS_WIFI_CtrlMsg() API More information can be found in the SYS_WIFI_CtrlMsg examples resized_seqdig_WiFi_Multiclient ",
							" Wi-Fi System Service Configuration The Wi-Fi System Service library should be configured through MHC(MPLAB Harmony Configurator) The following figure shows the MHC configuration window for configuring the Wi-Fi System Service and a brief description of various configuration options When user select the Wi-Fi System Service library all the required dependencies are added automatically into the MHC configuration In the Wi-Fi System Service library user can select the operating device mode as station(STA) or access point(AP) and make a required changes in the selected mode Wi-Fi_service_MHC ",
							" Configuration Options: Using MHC menu user can select required device mode as a station(STA) or access point(AP) ",
							" Device Mode: Indicates the device operation mode(STA/AP) ",
							" STA Mode: SSID: Access Point (AP/Router) SSID to connect Security type : Indicates the security being used by the AP with which device should connect - OPEN / WPA2 / WPAWPA2 (Mixed)/ WPA3 / WPAWPA2 Enterprise / WPA2 Enterprise / WPA2WPA3 Enterprise / WPA3 Enterprise When User Select Any Enterprise mode below configuration options are enable: User Name : User name that has been added in the Radius Server Username and Domainname : Provide EAP Identity info( username@domainname or domainname/username ) Server Domain Name SAN : Server domain name against which either server certificate's subject alternative name(SAN) or common name(CN) shall be matched for successful enterprise connection Server Domain Name CN : Server domain name against which either server certificate's subject alternative name(SAN) or common name(CN) shall be matched for successful enterprise connection Certificate Date : Enter a date between the date of certificate creation and date of expiration of certificate in UTC time format CA Certificate Format : Indicates the format of the CA Certificate that is used – PEM / DER CA Certificate File Name : Indicates the name of the header file that has to be included which contains the CA Certificate in the form of a hex array and the size of the hex array CA Certificate Module Name : Indicates the name of the array within the header file Private Certificate Format : Indicates the format of the Private Certificate that is used – PEM / DER Private Certificate File Name : Indicates the name of the header file that has to be included which contains the Private Certificate in the form of a hex array and the size of the hex array Private Certificate Module Name : Indicates the name of the array within the header file Private Key Format : Indicates the format of the Private Key that is used – PEM / DER Private Key File Name : Indicates the name of the header file that has to be included which contains the Private Key in the form of a hex array and the size of the hex array Private Key Module Name : Indicates the name of the array within the header file - Make sure that the date provided is within the validity period of the certificate - Make sure that the header files provided are imported into the project to avoid compilation error of missing file - More information can be found in \"WFI32 Enterprise Security Application Note\" Salesforce knowledge base article Password: Password to be used while connecting to the AP This is mandatory if security mode is set to anything other than OPEN It will be ignored if security mode is set to OPEN Auto Connect: Indicate whether to auto connect to AP (enable) or wait for user input (disable) ",
							" AP Mode: SSID: Indicate AP mode SSID Security: Indicate AP mode security: - OPEN - WPA2 - WPAWPA2(Mixed) - WPA3 Password: Indicate AP mode password(passphrase) SSID Visibility: Indicate AP mode SSID visibility Channel: Indicate operating channel of AP mode ",
							" Advanced configuration: Country code: Regulatory domain country code configuration: - GEN - General - USA - North America - EMEA - Europe - JPN - Japan Number of Clients: Indicates the maximum number of clients user can register Enable Wi-Fi Provisioning service: Enables/Disables Wi-Fi Provisioning System Service functionality along with Wi-Fi System Service Enable Power Save: Enables/Disables Power Save functionality Set PIC Power Save Mode: XDS - Extreme Deep Sleep mode DS - Deep Sleep Mode SLEEP - Sleep Mode DREAM - Dream Mode IDLE - Idle mode Set PIC Wi-Fi Correlation Mode: SYNC - Synchronous mode ASYNC - Asynchronous mode Set PIC Wi-Fi Power Save Mode: RUN - Wi-Fi Subsystem in Run Mode WSM - Wi-Fi Subsystem in Wi-Fi Sleep Mode(WSM) WDS - Wi-Fi Subsystem in Wi-Fi Deep Sleep Mode(WDS) WOFF - Wi-Fi Subsystem in Wi-Fi Power off Mode(WOFF) Set PIC Wi-Fi Power Save Mode: RUN - Wi-Fi Subsystem in Run Mode WSM - Wi-Fi Subsystem in Wi-Fi Sleep Mode(WSM) WDS - Wi-Fi Subsystem in Wi-Fi Deep Sleep Mode(WDS) WOFF - Wi-Fi Subsystem in Wi-Fi Power off Mode(WOFF) Set PIC Wi-Fi Wakeup Source: LISTEN INTERVAL - Wi-Fi Listern interval Set Wi-Fi Listen Interval: Set Wi-Fi Listen Interval Value Set Wi-Fi Sleep Inactivity Threshould/Limit Value: Set Wi-Fi Sleep Inactivity when Wi-Fi Subsystem should wakeup It can same as Association timeout DTIM - Enable Delivery Traffic Indication Message (DTIM) Wakeup - More details of the Low Power Mode is available in the Datasheet - The Wi-Fi System Service library only generate code which needed before Wi-Fi connection Please check low power \"Paho MQTT Client Power Save\" application for complete implemetation - The WSM/WDS is Connected Sleep mode Enable Wi-Fi Scanning: Enables/Disables Wi-Fi Scan functionality of Wi-Fi System Service Channel Number: Values of Scan Channel Number: 0 - scan all the channels 1 to 13 - - scan on specified channel Scan Mode: ACTIVE : Requst Active Scan PASSIVE : Request Passive Scan SSID List(Active Scan Only): User preferred SSIDs list for scanning Maximum 4 SSIDs of maximum 32 characters allowed e g DEMO_AP1 DEMO_AP2 DEMO_AP3 DEMO_AP4) This field is only applicable for Active Scan SSID List Delimiter character: Delimiter used for separating names in the \"SSID List(Active Scan Only)\" field Bitwise Channel Scan Mask: - 0x3fff : All 2 4GHZ channels - 0x07ff : 2 4GHz channels 1 through 11 (USA) - 0x1fff : 2 4GHz channels 1 through 13 (Europe) - 0x3fff : 2 4GHz channels 1 through 14(Asia) - 0x0001 : 2 4GHz (2412 MHz) channel 1 - 0x0002 : 2 4GHz (2412 MHz) channel 2 - User can find more details of mask value in the WDRV_PIC32MZW_CHANNEL24_MASK Number Of Slots: The number of scan slots per channel Active Slot Time: Time(in milliseconds) spent on each active channel to send the probe requests to find near by BSS's Passive Slot Time: Time(in milliseconds) spent on each passive channel listening for beacons Number Of Probes: Number of probe requests to be sent for each scan slot when \"SSID List\" field is empty Number of probe requests to be sent for each ssid to scan in each scan slot when preferred \"SSID List\" is configured This field is only applicable for Active Scan Scan Match Mode: FIND_ALL: Scan for all matches STOP_ON_FIRST : Stop scan on first match Enable Debug Logs: Enables/Disables Wi-Fi and Wi-Fi Provisioning System Service flows and levels Note: In case the user enables debug logs user needs to manually add the 'App Debug Service' component from Wireless- System Service- App Debug Service ",
							" Enabling Wi-Fi System Service All of the required files are automatically added into the MPLAB X IDE project by the MHC when the library is selected for use ",
							" Wi-Fi System Service Interface ",
							" Data Types and Constants Summary Name Description SYS_WIFI_AUTH Identifies the type of Authentication requested SYS_WIFI_CTRLMSG Identifies the control message for which the client has called SYS_WIFI_MODE Identifies the Wi-Fi operating mode SYS_WIFI_SCAN_MODES Identifies the Wi-Fi scanning mode SYS_WIFI_STA_CONFIG Configuration of station parameters SYS_WIFI_STA_APP_INFO Information related to connected station shared with Application SYS_WIFI_AP_CONFIG Configuration of access point mode parameters SYS_WIFI_CONFIG Configuration of device configuration parameters SYS_WIFI_SCAN_CONFIG Configuration of ssid scan parameters SYS_WIFI_STATUS Result of a Wi-Fi service client interface get status SYS_WIFI_RESULT Result of a Wi-Fi system service client interface operation SYS_WIFI_CALLBACK Pointer to a Wi-Fi system service callback function ",
							" Initialization functions Summary Name Description SYS_WIFI_Initialize Initializes the System Wi-Fi module SYS_WIFI_Deinitialize Deinitializes the module instance of the system Wi-Fi service ",
							" Status functions Summary Name Description SYS_WIFI_GetStatus Returns Wi-Fi system service status ",
							" Setup functions Summary Name Description SYS_WIFI_Tasks Maintains the Wi-Fi System tasks and functionalities SYS_WIFI_CtrlMsg Returns success/ failure for the connect/disconnect/scan operation asked by client ",
							" SYS_WIFI_STATUS Enum ",
							" C typedef enum { /* Wi-Fi system service is in init status */ SYS_WIFI_STATUS_INIT = 1 /* Wi-Fi system service is in driver open status */ SYS_WIFI_STATUS_WDRV_OPEN_REQ /* Wi-Fi system service is in auto connect wait status */ SYS_WIFI_STATUS_AUTOCONNECT_WAIT /* Wi-Fi system service is in wait for TCPIP stack init status */ SYS_WIFI_STATUS_TCPIP_WAIT_FOR_TCPIP_INIT /* Wi-Fi system service is in Wi-Fi connect request status */ SYS_WIFI_STATUS_CONNECT_REQ /* In AP mode Wi-Fi system service is in wait for AP IP address */ SYS_WIFI_STATUS_WAIT_FOR_AP_IP /* In AP mode Wi-Fi system service is in wait for connecting STA IP address */ SYS_WIFI_STATUS_WAIT_FOR_STA_IP /* Wi-Fi system service is in TCPIP ready status waiting for client request */ SYS_WIFI_STATUS_TCPIP_READY /* Wi-Fi system service is in TCPIP error status */ SYS_WIFI_STATUS_TCPIP_ERROR /* Wi-Fi system service is in config error status */ SYS_WIFI_STATUS_CONFIG_ERROR /* Wi-Fi system service is in connection error status */ SYS_WIFI_STATUS_CONNECT_ERROR /* Wi-Fi system service is in not in valid status */ SYS_WIFI_STATUS_NONE =255 } SYS_WIFI_STATUS; ",
							" Summary Result of a Wi-Fi service client interface get status operation(SYS_WIFI_GetStatus()) ",
							" Description Result of a Wi-Fi service client interface get status operation(SYS_WIFI_GetStatus()) ",
							" Remarks None ",
							" SYS_WIFI_MODE Enum ",
							" C typedef enum { /* Requesting a operating mode a AP access point */ SYS_WIFI_AP = 1 } SYS_WIFI_MODE ; ",
							" Summary Identifies the Wi-Fi operating mode ",
							" Description Identifies the Wi-Fi operating mode ",
							" Remarks Client need to manually reboot device after switching mode For example changing operating mode to STA to AP or AP to STA ",
							" SYS_WIFI_CTRLMSG Enum ",
							" C typedef enum { /* Control message type for requesting a Wi-Fi Configuration set(for connect) */ SYS_WIFI_CONNECT = 0 /*Control message type for requesting a Wi-Fi device disconnect */ SYS_WIFI_DISCONNECT /*Control message type for auto reconnect failure */ SYS_WIFI_AUTO_CONNECT_FAIL /* Control message type for requesting a Wi-Fi configuration information */ SYS_WIFI_GETWIFICONFIG /* Control message type for updating a Provisioning Wi-Fi configuration information */ SYS_WIFI_PROVCONFIG /* Control message type for registering a Wi-Fi system service client callback */ SYS_WIFI_REGCALLBACK /*Control message type for requesting a Wi-Fi driver handle */ SYS_WIFI_GETDRVHANDLE } SYS_WIFI_CTRLMSG ; ",
							" Summary Identifies the control message for which the client has called the SYS_WIFI_CtrlMsg() ",
							" Description Identifies the control message for which the client has called the SYS_WIFI_CtrlMsg() ",
							" Remarks The different control messages which can be invoked by the client ",
							" SYS_WIFI_RESULT Enum ",
							" C typedef enum{ /* Operation completed with success */ SYS_WIFI_SUCCESS = 0 /* Operation Failed */ SYS_WIFI_FAILURE /* Wi-Fi service un-initialize */ SYS_WIFI_SERVICE_UNINITIALIZE /*Wi-Fi configuration request failed */ SYS_WIFI_CONFIG_FAILURE //Wi-Fi Connect request failed SYS_WIFI_CONNECT_FAILURE //Wi-Fi Save request failed SYS_WIFI_SAVE_FAILURE //Operation request object is invalid SYS_WIFI_OBJ_INVALID=255 }SYS_WIFI_RESULT; ",
							" Summary Result of a Wi-Fi system service client interface operation ",
							" Description Identifies the result of Wi-Fi service operations ",
							" Remarks None ",
							" SYS_WIFI_SCAN_MODES Enum ",
							" C typedef enum { /* Requesting Passive Scan Mode */ SYS_WIFI_SCAN_MODE_PASSIVE = 0 /* Requesting Active Scan Mode */ SYS_WIFI_SCAN_MODE_ACTIVE } SYS_WIFI_SCAN_MODES ; ",
							" Summary Identifies the Wi-Fi scanning mode ",
							" Description Identifies the Wi-Fi scanning mode ",
							" Remarks None ",
							" SYS_WIFI_AUTH Enum ",
							" C typedef enum { /* Requesting a Open Authentication types */ SYS_WIFI_OPEN = 1 /* Requesting a WEP Authentication types */ SYS_WIFI_WEP /* Requesting a WPA/WPA2(Mixed) Authentication types */ SYS_WIFI_WPAWPA2MIXED /* Requesting a WPA2 Authentication types */ SYS_WIFI_WPA2 /* Requesting a WPA2/WPA3(Mixed) Authentication types */ SYS_WIFI_WPA2WPA3MIXED /* Requesting a WPA3 Authentication types */ SYS_WIFI_WPA3 } SYS_WIFI_AUTH ; ",
							" Summary Identifies the type of Authentication requested ",
							" Description Identifies the type of Authentication requested ",
							" Remarks None ",
							" SYS_WIFI_AP_CONFIG Struct ",
							" C typedef struct { /* Wi-Fi access point mode SSID */ uint8_t ssid[32]; /* Wi-Fi access point mode passphrase */ uint8_t psk[64]; /* Wi-Fi access point mode authentication type */ SYS_WIFI_AUTH authType; /* Wi-Fi access point mode channel number values of channel: 1 to 13 - - operating channel of access point */ uint8_t channel; /* Wi-Fi access point mode SSID visibility value of ssidVisibility: 0 - Hidden SSID 1 - broadcast the SSID */ bool ssidVisibility; } SYS_WIFI_AP_CONFIG; ",
							" Summary Configuration of access point mode parameters ",
							" Description Configuration of access point mode parameters ",
							" Remarks None ",
							" SYS_WIFI_CONFIG Struct ",
							" C typedef struct { /* Operating mode of the device */ SYS_WIFI_MODE mode; /* Flag to identify if configuration needs to be saved in NVM 0 - Do not save configuration in NVM 1 - Save configuration in NVM */ uint8_t saveConfig; /* Country Code configuration */ uint8_t countryCode[6]; /* Wi-Fi access point mode configuration structure */ SYS_WIFI_AP_CONFIG apConfig; }SYS_WIFI_CONFIG; ",
							" Summary Configuration of device configuration parameters ",
							" Description Configuration of device configuration parameters ",
							" Remarks None ",
							" SYS_WIFI_STA_CONFIG Struct ",
							" C typedef struct { /* Wi-Fi station mode SSID */ uint8_t ssid[33]; /* Wi-Fi station mode passphrase */ uint8_t psk[64]; /* Wi-Fi station mode authentication type */ SYS_WIFI_AUTH authType; /* Wi-Fi station mode channel number values of channel: 0 - scan and connect to all the channels 1 to 13 - - scan and connect to specified channel */ uint8_t channel; /* Wi-Fi station mode auto connect flag value 0- Don't connect to AP wait for client request value 1- Connect to AP immediately */ bool autoConnect; /* Wi-Fi station mode IP address */ IPV4_ADDR ipAddr; } SYS_WIFI_STA_CONFIG; ",
							" Summary Configuration of station parameters ",
							" Description Configuration of station parameters ",
							" Remarks None ",
							" SYS_WIFI_SCAN_CONFIG Struct ",
							" C typedef struct { /* Wi-Fi station mode SSID */ uint8_t ssid[33]; /* Wi-Fi station mode passphrase */ uint8_t psk[64]; /* Wi-Fi station mode authentication type */ SYS_WIFI_AUTH authType; /* Wi-Fi station mode channel number values of channel: 0 - scan and connect to all the channels 1 to 13 - - scan and connect to specified channel */ uint8_t channel; /* Wi-Fi station mode auto connect flag value 0- Don't connect to AP wait for client request value 1- Connect to AP immediately */ bool autoConnect; /* Wi-Fi station mode IP address */ IPV4_ADDR ipAddr; } SYS_WIFI_STA_CONFIG; ",
							" Summary Configuration of ssid scan parameters ",
							" Description Configuration of ssid scan parameters ",
							" Remarks None ",
							" SYS_WIFI_STA_APP_INFO Struct ",
							" C typedef struct { /* IP Address of the station */ IPV4_ADDR ipAddr; /* MAC Address of the station */ uint8_t macAddr[6]; } SYS_WIFI_STA_APP_INFO; ",
							" Summary Information related to connected station shared with Application ",
							" Description Information (MAC Address IP Address) related to connected station ",
							" Remarks None ",
							" SYS_WIFI_CALLBACK Typedef ",
							" C typedef void (*SYS_WIFI_CALLBACK )(uint32_t event void * data void *cookie ); ",
							" Summary Pointer to a Wi-Fi system service callback function ",
							" Description This data type defines a pointer to a Wi-Fi service callback function Callback functions can be registered by client at initialization or using control message type ",
							" Precondition The Wi-Fi service must have been initialized using the SYS_WIFI_Initialize function if client registering callback using control message ",
							" Parameters Param Description event A event value event can be any of SYS_WIFI_CTRLMSG types data Wi-Fi service Data cookie Client register cookie ",
							" Returns None ",
							" Example //User can refer the application \"wireless_apps_pic32mzw1_wfi32e01 apps wifi_easy_config\" for more information on how to implement callback APP_DATA appData; void WiFiServCallback (uint32_t event void * data void *cookie ) { IPV4_ADDR *IPAddr; switch(event) { case SYS_WIFI_CONNECT: { //In STA mode Wi-Fi service share IP address provided by AP in the callback IPAddr = (IPV4_ADDR *)data; SYS_CONSOLE_PRINT(\"IP address obtained = %d %d %d %d r n\" IPAddr- v[0] IPAddr- v[1] IPAddr- v[2] IPAddr- v[3]); //In AP mode Wi-Fi service share MAC address and IP address of the connected STA in the callback SYS_WIFI_STA_APP_INFO *StaConnInfo = (SYS_WIFI_STA_APP_INFO *)data; SYS_CONSOLE_PRINT(\"STA Connected to AP Got IP address = %d %d %d %d r n\" StaConnInfo- ipAddr v[0] StaConnInfo- ipAddr v[1] StaConnInfo- ipAddr v[2] StaConnInfo- ipAddr v[3]); SYS_CONSOLE_PRINT(\"STA Connected to AP Got MAC address = %x:%x:%x:%x:%x:%x r n\" StaConnInfo- macAddr[0] StaConnInfo- macAddr[1] StaConnInfo- macAddr[2] StaConnInfo- macAddr[3] StaConnInfo- macAddr[4] StaConnInfo- macAddr[5]); break; } case SYS_WIFI_DISCONNECT: { SYS_CONSOLE_PRINT(\"Device DISCONNECTED r n\"); break; } case SYS_WIFI_PROVCONFIG: { SYS_CONSOLE_PRINT(\"Received the Provisioning data r n\"); break; } } } void APP_Initialize(void) { appData state = APP_STATE_INIT; } void APP_Tasks(void) { switch (appData state) { case APP_STATE_INIT: { SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_REGCALLBACK WiFiServCallback sizeof(uint8_t *)); appData state=APP_STATE_SERVICE_TASKS; break; } case APP_STATE_SERVICE_TASKS: { break; } default: { break; } } } ",
							" Remarks None ",
							" SYS_WIFI_CtrlMsg Function ",
							" C SYS_WIFI_RESULT SYS_WIFI_CtrlMsg ( SYS_MODULE_OBJ object uint32_t event void *buffer uint32_t length ) ",
							" Summary Returns success/ failure for the connect/disconnect/scan operation asked by client ",
							" Description This function is used to make control message request (connect disconnect scan register callback) to Wi-Fi system service ",
							" Precondition The SYS_WIFI_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFI object handle returned from SYS_WIFI_Initialize event A event value event can be any of SYS_WIFI_CTRLMSG types buffer Control message data input length size of buffer data ",
							" Returns return SYS_WIFI_RESULT ",
							" Example Details of SYS_WIFI_CONNECT: SYS_WIFI_CONFIG wifiSrvcConfig; SYS_MODULE_OBJ WiFiServHandle; // Set mode as STA wifiSrvcConfig mode = SYS_WIFI_STA; // Disable saving wifi configuration wifiSrvcConfig saveConfig = false; // Set the auth type to SYS_WIFI_WPA2 wifiSrvcConfig staConfig authType = SYS_WIFI_WPA2; // Enable all the channels(0) wifiSrvcConfig staConfig channel = 0; // Device doesn't wait for user request wifiSrvcConfig staConfig autoConnect = 1; // Set SSID memcpy(wifiSrvcConfig staConfig ssid WIFI_DEV_SSID sizeof(WIFI_DEV_SSID)); // Set PSK memcpy(wifiSrvcConfig staConfig psk WIFI_DEV_PSK sizeof(WIFI_DEV_PSK)); // sysObj syswifi return from SYS_WIFI_Initialize() if (SYS_WIFI_OBJ_INVALID = SYS_WIFI_CtrlMsg (sysObj syswifi SYS_WIFI_CONNECT wifiSrvcConfig sizeof(SYS_WIFI_CONFIG))) { } Details of SYS_WIFI_GETDRVHANDLE: // Get Wi-Fi Driver handle using control message request DRV_HANDLE myWifiDrvHandle; if(SYS_WIFI_SUCCESS == SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_GETDRVHANDLE myWifiDrvHandle sizeof(DRV_HANDLE))) { //Received the handle } Details of SYS_WIFI_REGCALLBACK: // Client can register multiple callback Number of supported // callback registration is a MHC configuration SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_REGCALLBACK WiFiServCallback sizeof(uint8_t *)); Details of SYS_WIFI_GETWIFICONFIG: // Get Wi-Fi Configuration using control message request // The information of configuration is updated in the wifiSrvcConfig SYS_WIFI_CONFIG wifiSrvcConfig; if(SYS_WIFI_SUCCESS == SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_GETWIFICONFIG wifiSrvcConfig sizeof(SYS_WIFI_CONFIG))) { //Received the wifiSrvcConfig data } Details of SYS_WIFI_DISCONNECT: //In STA mode device disconnect request using control message SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_DISCONNECT NULL 0); // In AP mode How to disconnect connected STA // When STA connect to AP mode application received the callback(SYS_WIFI_CONNECT) with connect STA IP and MAC address // User same MAC address for disconnect request SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_DISCONNECT macAddr 6); ",
							" Remarks None ",
							" SYS_WIFI_Deinitialize Function ",
							" C SYS_WIFI_RESULT SYS_WIFI_Deinitialize (SYS_MODULE_OBJ object) ",
							" Summary Deinitializes the module instance of the system Wi-Fi service ",
							" Description This function deinitializes the module instance disabling its operation Resets all of the internal data structures and fields to the default settings ",
							" Precondition The SYS_WIFI_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFI object handle returned from SYS_WIFI_Initialize ",
							" Returns return SYS_WIFI_RESULT ",
							" Example if (SYS_WIFI_SUCCESS == SYS_WIFI_Deinitialize (sysObj syswifi)) { // when the SYS WIFI is De-initialized } ",
							" Remarks Deinitialize should be called if the WiFi service is no longer going to be used ",
							" SYS_WIFI_GetStatus Function ",
							" C uint8_t SYS_WIFI_GetStatus ( SYS_MODULE_OBJ object) ",
							" Summary Returns Wi-Fi system service status ",
							" Description This function returns the current status of the System Wi-Fi service This function help user to perform synchronize functionality with Wi-Fi service ",
							" Precondition The SYS_WIFI_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFI object handle returned from SYS_WIFI_Initialize ",
							" Returns return SYS_WIFI_STATUS if client provided object is valid else return SYS_WIFI_OBJ_INVALID ",
							" Example // For example User want to perform the Scan request when auto connect is disabled // So user has to make sure service is in right state // where Wi-Fi service has started and waiting in the Auto connect // state(SYS_WIFI_STATUS_AUTOCONNECT_WAIT) before making scan request if (SYS_WIFI_STATUS_AUTOCONNECT_WAIT == SYS_WIFI_GetStatus (sysObj syswifi)) { // Enable Wi-Fi Scanning in MHC // Get Wi-Fi Scan Configuration using control message request // The information of configuration is updated in the wifiSrvcScanConfig SYS_WIFI_SCAN_CONFIG wifiSrvcScanConfig; if(SYS_WIFI_SUCCESS == SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_GETSCANCONFIG wifiSrvcScanConfig sizeof(SYS_WIFI_SCAN_CONFIG))) { //Received the wifiSrvcScanConfig data } // update desired parameters char myAPlist[] = \"openAP SecuredAP DEMO_AP my_cell_hotspot\"; char delimiter = ' '; wifiSrvcScanConfig channel = 6; wifiSrvcScanConfig mode = SYS_WIFI_SCAN_MODE_ACTIVE; wifiSrvcScanConfig pSsidList = myAPlist; wifiSrvcScanConfig delimChar = delimiter; // pass structure in scan request SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_SCANREQ wifiSrvcScanConfig sizeof(SYS_WIFI_SCAN_CONFIG)); } //Wi-Fi system service is in TCPIP ready status waiting for client request if (SYS_WIFI_STATUS_TCPIP_READY == SYS_WIFI_GetStatus (sysObj syswifi)) { // when the SYS WIFI module in TCPIP ready STATUS } ",
							" Remarks None ",
							" SYS_WIFI_Initialize Function ",
							" C SYS_MODULE_OBJ SYS_WIFI_Initialize ( SYS_WIFI_CONFIG *config SYS_WIFI_CALLBACK callback void *cookie ) ",
							" Summary Initializes the System Wi-Fi module ",
							" Description Wi-Fi service supports only one single instance of Wi-Fi ",
							" Parameters Param Description config Wi-Fi device configuration structure callback The client callback function pointer cookie The pointer which will be passed to the customer application when the customer callback function is invoked ",
							" Returns If successful returns a valid handle to an object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example #define WIFI_DEV_SSID \"DEMO_AP\" #define WIFI_DEV_PSK \"password\" SYS_WIFI_CONFIG wifiSrvcConfig; // Set mode as STA wifiSrvcConfig mode = SYS_WIFI_STA; // Disable saving wifi configuration wifiSrvcConfig saveConfig = false; // Set the auth type to SYS_WIFI_WPA2 wifiSrvcConfig staConfig authType = SYS_WIFI_WPA2; // Enable all the channels(0) wifiSrvcConfig staConfig channel = 0; // Device doesn't wait for user request wifiSrvcConfig staConfig autoConnect = 1; // Set SSID memcpy(wifiSrvcConfig staConfig ssid WIFI_DEV_SSID sizeof(WIFI_DEV_SSID)); // Set PSK memcpy(wifiSrvcConfig staConfig psk WIFI_DEV_PSK sizeof(WIFI_DEV_PSK)); sysObj syswifi = SYS_WIFI_Initialize( wifiSrvcConfig WiFiServCallback 0); if (sysObj syswifi == SYS_MODULE_OBJ_INVALID) { // Handle error } ",
							" Remarks This routine can only be called once during system initialization If the Wi-Fi system service is enabled using MHC then auto generated code will take care of system wi-fi initialization ",
							" SYS_WIFI_Tasks Function ",
							" C uint8_t SYS_WIFI_Tasks ( SYS_MODULE_OBJ object) ",
							" Summary Maintains the Wi-Fi System tasks and functionalities ",
							" Description This function is used to run the various tasks and functionalities of Wi-Fi system service ",
							" Precondition The SYS_WIFI_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFI object handle returned from SYS_WIFI_Initialize ",
							" Returns return SYS_WIFI_STATUS if client provided object is valid else return SYS_WIFI_OBJ_INVALID ",
							" Example if (SYS_WIFI_OBJ_INVALID = SYS_WIFI_Tasks (sysObj syswifi)) { } ",
							" Remarks If the Wi-Fi system service is enabled using MHC then auto generated code will take care of system task execution ",
							" Wi-Fi System Service Developer's Guide ",
							" Code modification/implementation guide for common use cases ",
							" Wi-Fi System Service Auto Connect When user enables the auto connect features using Wi-Fi service system MHC menu the default auto connect retry count is configured to 5 User can modify the macro MAX_AUTO_CONNECT_RETRY in generated file sys_wifi c as per their choice PIC32MZW1 device stops the connection request to AP after retry count reaches to zero and successful connections with AP is not established /* Wi-Fi STA Mode maximum auto connect retry */ #define MAX_AUTO_CONNECT_RETRY 5 ",
							" Wi-Fi System Service Scan Example Wi-Fi System Service support scan functinality both in STA and AP mode In case user want to overwrite MHC configuration of the scan parameter please find the below snippet code that need to be added in the application #include \"wdrv_pic32mzw_bssfind h\" APP_DATA appData; SYS_WIFI_SCAN_CONFIG scanConfig; /* Wi-Fi driver triggers a callback to update each Scan result one-by-one*/ bool APP_ScanHandler (DRV_HANDLE handle uint8_t index uint8_t ofTotal WDRV_PIC32MZW_BSS_INFO *pBSSInfo) { if (0 == ofTotal) { SYS_CONSOLE_MESSAGE(\"No AP Found Rescan r n\"); } else { if (index == 1) { SYS_CONSOLE_PRINT(\"Scan Results: #%02d r n\" ofTotal); } SYS_CONSOLE_PRINT(\"[%02d] %s r n\" index pBSSInfo- ctx ssid name); } // return true to receive further results; otherwise return false if desired return true; } void APP_Initialize(void) { appData state = APP_STATE_INIT; } void APP_Tasks(void) { SYS_WIFI_RESULT res; SYS_WIFI_STATUS wifiStatus; switch (appData state) { case APP_STATE_INIT: { appData state = APP_STATE_TRIGGER_SCAN; break; } case APP_STATE_TRIGGER_SCAN: { wifiStatus = SYS_WIFI_GetStatus (sysObj syswifi); if (wifiStatus SYS_WIFI_STATUS_WDRV_OPEN_REQ) { memset( scanConfig 0 sizeof(scanConfig)); res = SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_GETSCANCONFIG scanConfig sizeof(SYS_WIFI_SCAN_CONFIG)); if(SYS_WIFI_SUCCESS == res) { //Received the wifiSrvcScanConfig data char myAPlist[] = \"\"; // e g \"myAP*OPENAP*Hello World \" char delimiter = '*'; scanConfig channel = 0; scanConfig mode = SYS_WIFI_SCAN_MODE_ACTIVE; scanConfig pSsidList = myAPlist; scanConfig delimChar = delimiter; scanConfig pNotifyCallback = (void *)APP_ScanHandler; scanConfig matchMode = WDRV_PIC32MZW_SCAN_MATCH_MODE_FIND_ALL; SYS_CONSOLE_PRINT(\" r nStarting Custom Scan r n\"); res = SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_SCANREQ scanConfig sizeof(SYS_WIFI_SCAN_CONFIG)); if(SYS_WIFI_SUCCESS = res) { SYS_CONSOLE_PRINT(\"Error Starting scan: %d r n\" res); appData state = APP_STATE_ERROR; break; } appData state = APP_STATE_DONE; } else { SYS_CONSOLE_PRINT(\"Error retrieving scan config: %d r n\" res); appData state = APP_STATE_ERROR; } } break; } case APP_STATE_DONE: { // wait for custom scan to complete and do nothing later break; } case APP_STATE_ERROR: { break; } default: { break; } } } User can initiate the Scan request with default Wi-Fi System service MHC menu configuration with below code snippet Wi-Fi_service_SCAN_MHC SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_SCANREQ NULL 0); ",
							" How to Disconnect Connected STA in AP Mode Using Wi-Fi System Service Please see the code snippet below for reference #include \"app h\" #include \"definitions h\" APP_DATA appData; static SYS_WIFI_CONFIG wificonfig; void WiFiServCallback(uint32_t event void * data void *cookie) { IPV4_ADDR *IPAddr; switch (event) { case SYS_WIFI_CONNECT: { IPAddr = (IPV4_ADDR *) data; if (SYS_WIFI_STA == wificonfig mode) { SYS_CONSOLE_PRINT(\"Connected to AP Got IP address = %d %d %d %d r n\" IPAddr- v[0] IPAddr- v[1] IPAddr- v[2] IPAddr- v[3]); } else { SYS_WIFI_STA_APP_INFO *psStaConnInfo = (SYS_WIFI_STA_APP_INFO *)data; SYS_CONSOLE_PRINT(\"STA Connected to AP Got IP address = %d %d %d %d r n\" psStaConnInfo- ipAddr v[0] psStaConnInfo- ipAddr v[1] psStaConnInfo- ipAddr v[2] psStaConnInfo- ipAddr v[3]); SYS_CONSOLE_PRINT(\"STA Connected to AP Got MAC address = %x:%x:%x:%x:%x:%x r n\" psStaConnInfo- macAddr[0] psStaConnInfo- macAddr[1] psStaConnInfo- macAddr[2] psStaConnInfo- macAddr[3] psStaConnInfo- macAddr[4] psStaConnInfo- macAddr[5]); SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_DISCONNECT psStaConnInfo- macAddr 6); } break; } case SYS_WIFI_DISCONNECT: { SYS_CONSOLE_PRINT(\"Device DISCONNECTED r n\"); break; } case SYS_WIFI_PROVCONFIG: { memcpy( wificonfig data sizeof(SYS_WIFI_CONFIG)); SYS_CONSOLE_PRINT(\"%s:%d Received Provisioning Data : r n Device mode=%s r n\" __func__ __LINE__ (wificonfig mode == SYS_WIFI_STA) \"STA\" : \"AP\"); if (SYS_WIFI_STA == wificonfig mode) { SYS_CONSOLE_PRINT(\" ssid=%s password=%s r n\" wificonfig staConfig ssid wificonfig staConfig psk); } else if (SYS_WIFI_AP == wificonfig mode) { SYS_CONSOLE_PRINT(\" ssid=%s password=%s r n\" wificonfig apConfig ssid wificonfig apConfig psk); } break; } } } void APP_Initialize(void) { appData state = APP_STATE_INIT; } void APP_Tasks(void) { switch (appData state) { case APP_STATE_INIT: { SYS_CONSOLE_PRINT(\"Application: wifi_easy_config r n\"); SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_REGCALLBACK WiFiServCallback sizeof (uint8_t *)); appData state = APP_STATE_GETCONFIG; break; } case APP_STATE_GETCONFIG: { if(SYS_WIFI_SUCCESS == SYS_WIFI_CtrlMsg(sysObj syswifi SYS_WIFI_GETWIFICONFIG wificonfig sizeof(SYS_WIFI_CONFIG))) { SYS_CONSOLE_PRINT(\"%s:%d Device mode=%s r n\" __func__ __LINE__ (wificonfig mode == SYS_WIFI_STA) \"STA\" : \"AP\"); appData state = APP_STATE_SERVICE_TASKS; } break; } case APP_STATE_SERVICE_TASKS: { break; } default: { break; } } } ",
							" Wi-Fi provisioning System Service Wi-Fi Provisioning System Service Library is used to enable Wi-Fi provisioning method Wi-Fi Provisioning is the process of configuring desired Wi-Fi SSID and related security credentials of the Home AP into the device This system service provides different methods that can be used to provide this information to the core stack Key Features: Wi-Fi Provisioning using command line Wi-Fi Provisioning using TCP Socket JSON Mobile Application Wi-Fi Provisioning using webpage(HTTP page) ",
							" Wi-Fi provisioning System Service Usage The Wi-Fi Provisioning System Service povides below methods to configuring desired Wi-Fi SSID and related security credentials of the Home AP into the device ",
							" Wi-Fi Provisioning Methods ",
							" Command line MHC configuration menu for Command line(CLI): SYS_Wi-Fi_Provision_MHC_diagram_1 Enable Check box \"Command Line(CLI)\" to include CLI Wi-Fi provisioning method After making configuration changes generate the code Compile the project and load the image into device Wi-Fi Provisioning commands Details Command Details Example wifiprovhelp Wi-Fi Provision System Service help command wifiprovhelp wifiprov set bootmode save config country code channel auto_connect authtype ssid_name psk_name Set Wi-Fi Configuration for Station(STA) mode wifiprov set 0 1 \"GEN\" 0 1 3 \"DEMO_AP\" \"password\" wifiprowifiprov set bootmode save config country code channel ssid_visibility authtype ssid_name psk_name Set Wi-Fi Configuration for Access point(AP) mode wifiprov set 1 1 \"GEN\" 1 1 3 \"DEMO_SOFTAP\" \"password\" wifiprov get Get Wi-Fi Configuration wifiprov get Wi-Fi Provisioning commands command parameters information Parameter Sub Parameter bootmode 0 - Station(STA) mode 1- Access point(AP) mode save config 0 - Do not save configuration in NVM(Program Flash Memory) 1- Save configuration in NVM country code country code configuration: GEN - General USA - North America EMEA - Europe CUST1 CUST2 - Customer custom regulatory configuration Channel In Station mode value range from 0-13 0 - select all the channels 1-13 - select specified channel In Access point mode value range from 1-13 auto connect(only applicable in STA mode) 0 - Don't connect to AP wait for client request 1 - Connect to AP ssid visibility (only applicable in AP mode) 0 - Hidden SSID 1 - Broadcast SSID authtype(Security type) 1 - OPEN Mode 3 - WPAWPA2 (Mixed) mode 4 - WPA2 mode 5 - WPA2WPA3 (Mixed) mode 6 - WPA3 mode ssid(ssid name) SSID name psk name(password) Password/passphrase Note: Wi-Fi Provisioning using command line method is not recommended in production release due to security concerns All commands the parameters are mandatory and none are optional except for password in case of \"open\" authentication ",
							" TCP Socket mode MHC configuration menu for TCP Socket: SYS_Wi-Fi_Provision_MHC_diagram_1 Enable Check box \"TCP Socket\" to include TCP Socket Wi-Fi provisioning method Modifiy the \"Socket Server Port\" Defult port number is 6666 After making configuration changes generate the code Compile the project and load the image into device Wi-Fi provisioning service can be configured to use TCP socket a socket server is activated when the device boots Use a laptop or mobile phone as a TCP client to connect to the device's socket server Wi-Fi provisioning service defult TCP server port is 6666 ",
							" Wi-Fi provisioning with JSON format User can send the below JSON format data from TCP Client to provisioning the device Example: { \"mode\": 0 \"save_config\": 1 \"countrycode\":\"GEN\" \"STA\": { \"ch\": 0 \"auto\": 1 \"auth\": 3 \"SSID\": \"DEMO_AP\" \"PWD\":\"password\"} \"AP\": {\"ch\": 2 \"ssidv\": 1 \"auth\": 4 \"SSID\": \"DEMO_AP_SOFTAP\" \"PWD\": \"password\" } } Details of JSON Parameters Parameter Sub Parameter Value Details mode  0 - Station(STA) mode 1- Access point(AP) mode save_config  0 - Do not save configuration in NVM 1- Save configuration in NVM STA ch (Channel) In Station mode value range from 0-13 0 - select all the channels 1-13 - select specified channel  auto(auto connect) 0 - Don't connect to AP wait for client request 1 - Connect to AP  Auth(Security type) 1 - OPEN Mode 3 - WPAWPA2 (Mixed) mode 4 - WPA2 mode 5 - WPA3 mode  SSID(ssid name) SSID name  PWD(password) Password/passphrase AP ch (Channel) In Access point mode value range from 1-13  ssidv(ssid visibility) 0 - Hidden SSID 1 - Broadcast SSID  Auth(Security type) 1 - OPEN Mode 3 - WPAWPA2 (Mixed) mode 4 - WPA2 mode 5 - WPA2WPA3 (Mixed) mode 6 - WPA3 mode  SSID(ssid name) SSID name  PWD(password) Password/passphrase ",
							" Wi-Fi provisioning with Mobile Application Follow below steps to provisioning the device using mobile application: Download and install the mobile application \"Wi-Fi Provisioning\" from Android play store Start PIC32MZW1 device in AP mode (Configure Wi-Fi Service \"Device Mode\" as \"AP\") Using mobile Wi-Fi setting make a Wi-Fi connection to PIC32MZW1 AP Mode SYS_Wi-Fi_Provision_Mobile_connect Open the \"Wi-Fi Provisioning\" application Enter PIC32MZW1 IP address as Server IP in the mobile application Enter the Wi-Fi provisioning System Service configured port number SYS_Wi-Fi_Provision_Mobile_app_home SCAN near by HOMEAP and select the desired HOMEAP Enter the password SYS_Wi-Fi_Provision_Mobile_app_scan_connect User can manually add provisioning information using \"Add New Network\" option also SYS_Wi-Fi_Provision_Mobile_app_add_new_network After provisioning the device reboot and connect to HOMEAP Sending the TCP data without mobile application: Using laptop or mobile phone as TCP client user can send the TCP data in below format to provisioning the device TCP Data Format : apply ssid Auth password NULL Parameter Details ssid(ssid name) SSID name Auth (security type) 1- OPEN MODE 2 - WPA2 Mode psk name(password) Password/passphrase ",
							" HTTP ",
							" Webpage using HTTP MHC configuration menu for HTTP (unsecure): SYS_Wi-Fi_Provision_MHC_diagram_2 Enable Check box \"HTTP\" to include Wi-Fi provisioning using webpage press \"Yes\"for components inclusion pop-up When user enable \"HTTP\" checkbox only defualt wi-f provising method enable with port number 80 After making configuration changes generate the code Compile the project and load the image into device Follow below steps to provisioning the device using HTTP: Start PIC32MZW1 device in AP mode (Configure Wi-Fi Service \"Device Mode\" as \"AP\") Connect Laptop or mobile phone to PIC32MZW1 AP device Open the browser and enter the PIC32MZW1 AP IP address(example: http://192 168 1 1/) SYS_Wi-Fi_Provision_HTTP_HOME Goto \"Network Configuratio\" page There are two ways of configuring a wifi network: \"Scan and Connect to Wifi Network\" and \"Static Wifi Configuration\" SYS_Wi-Fi_Provision_HTTP_Networkconfig In case of \"Scan and Connect\" one can scan (press the 'Start Scan' button) for the available APs in the vicinity and connect to the AP of one's choice SYS_Wi-Fi_Provision_HTTP_Networkconfig_ScanResults Click on the AP from the list you want to connect to In case of secured AP the user needs to give the password SYS_Wi-Fi_Provision_HTTP_Networkconfig_Password In case of Hidden Networks the SSID of the AP will not be visible In this case the user will need to give both SSID and the password SYS_Wi-Fi_Provision_HTTP_Networkconfig_HiddenNw For \"Static Wifi Configuration\" update the Configuration details and click on \"Apply Wi-Fi Configuration\" SYS_Wi-Fi_Provision_HTTP_Networkconfig_http Device will reboot and apply configuration in the device HTTP functionality is also supported in station(STA) mode ",
							" Webpage using HTTPNET (Un-Secure) MHC configuration menu for HTTPNET(Unsecure): SYS_Wi-Fi_Provision_MHC_diagram_3 Follow below steps to enable to HTTPNET unsecure Enable Check box \"Enable HTTPNET\" Configure \"Server port\" User can configure any valid port number Enable Check box \"HTTP\" and press \"Yes\"for components inclusion pop-up After making configuration changes generate the code Compile the project and load the image into device Follow below steps to provisioning the device using HTTP: Start PIC32MZW1 device in AP mode (Configure Wi-Fi Service \"Device Mode\" as \"AP\") Connect Laptop or mobile phone to PIC32MZW1 AP device Open the browser and enter the PIC32MZW1 AP IP address with port number(example: http://192 168 1 1:401/) SYS_Wi-Fi_Provision_HTTP_HOME Goto \"Network Configuratio\" page Update the Configuration details and click on \"Apply Wi-Fi Configuration\" SYS_Wi-Fi_Provision_HTTP_Networkconfig Device will reboot and apply configuration in the device ",
							" Webpage using HTTPNET (Secure) MHC configuration menu for HTTPNET(secure): SYS_Wi-Fi_Provision_MHC_diagram_4 Follow below steps to enable HTTPNET secure Enable Check box \"Enable HTTPNET\" Enable check box \"Enable Secure Connection with HTTPNET\" Configure \"Server port\" User can configure any valid port number Enable Check box \"HTTP\" and press \"Yes\"for components inclusion pop-up After making configuration changes generate the code Compile the project and load the image into device Follow below steps to provisioning the device using HTTP: Start PIC32MZW1 device in AP mode (Configure Wi-Fi Service \"Device Mode\" as \"AP\") Connect Laptop or mobile phone to PIC32MZW1 AP device Open the browser and enter the PIC32MZW1 AP IP address with port number(example: https://192 168 1 1:443/) SYS_Wi-Fi_Provision_HTTP_HOME Goto \"Network Configuratio\" page Update the Configuration details and click on \"Apply Wi-Fi Configuration\" SYS_Wi-Fi_Provision_HTTP_Networkconfig Device will reboot and apply configuration in the device ",
							" How The Library Works The Wi-Fi Provisioning System Service implemented Command line HTTP and Socket mode Wi-Fi Provisioning method Wi-Fi Provisioning System Service by default enabled along Wi-Fi System Service User can make configuration changes as per their application requirement ",
							" Execution Flow The following diagram shows how the Command line and Socket mode Wi-Fi Provisioning methods are enabled resized_SYS_Wi-Fi_Provision_Seq ",
							" Wi-Fi provisioning System Service Configuration The Wi-Fi Provisioning System Service library should be configured through MHC(MPLAB Harmony Configurator) The following figure shows the MHC configuration window for configuring the Wi-Fi Provisioning System Service and a brief description of various configuration options The Wi-Fi Provisioning System Service library MHC menu provide option to enable required Wi-Fi Provisioning methods base on user application requirements User can select Command line Socket mode and HTTP as shown in below diagram resized_SYS_Wi-Fi_Provision_MHC_diagram ",
							" Configuration Options: WiFi Configuration Stored At The Wi-Fi Provisioning System Service provide the two option to user to store the WiFi Configuration NVM : The Wi-Fi Provisioning System Service store the WiFi Configuration into NVM using it's internal framework WiFi Configuration Stored at NVM Address(Program Flash memory): NVM Address for storing Wi-Fi Configuration User can change this configuration value with program flash memory page aligned address The Wi-Fi Provisioning System Service by defult reserve 4KB from user provide NVM address for storing Wi-Fi Configuration User has to make sure the NVM address(Program Flash memory) page is not overwritten by application code Save Configuration in the NVM(Program flash memory): Indicates the Wi-Fi configuration storing in the NVM This configuration is only valid when \"Enable Wi-Fi Provisioning service\" is enabled User : The Wi-Fi Provisioning System Service don't store the WiFi Configuration into any memory The Wi-Fi Provisioning System generate the application callback using WiFi service with message type SYS_WIFI_PROVCONFIG for user to store and manage the WiFi Configuration as per their choice Wi-Fi Provisioning Methods Command Line(CLI): Enable/Disable Wi-Fi Provision using command line HTTP pages: Enable/Disable Wi-Fi Provision using HTTP pages(webpage) HTTP Socket Number: User configuration for HTTP Server Socket Defult port number is 80 TCP socket: Enable/Disable Wi-Fi Provision using TCP Socket TCP Socket Number: User configuration for TCP Server Socket Defult port number is 6666 TCP Socket port number is used by Mobile Applicaiton and JSON ",
							" Wi-Fi Provisioning System Service Interface ",
							" Data Types and Constants Summary Name Description SYS_WIFIPROV_AUTH Identifies the type of Authentication requested SYS_WIFIPROV_CTRLMSG Identifies the control message for which the client has called SYS_WIFIPROV_MODE Identifies the Wi-Fi operating mode SYS_WIFIPROV_STA_CONFIG Configuration of station parameters SYS_WIFIPROV_AP_CONFIG Configuration of access point mode parameters SYS_WIFIPROV_CONFIG Configuration of device configuration parameters SYS_WIFIPROV_STATUS Result of a Wi-Fi Provisioning system service client interface get SYS_WIFIPROV_RESULT Result of a Wi-Fi Provisioning system service client interface operation SYS_WIFIPROV_CALLBACK Pointer to a Wi-Fi Provisioning system service callback function ",
							" Initialization functions Summary Name Description SYS_WIFIPROV_Initialize Initializes the System Wi-Fi Provisioning module SYS_WIFIPROV_Deinitialize Deinitializes the module instance of the SYS WIFIPROV module ",
							" Status functions Summary Name Description SYS_WIFIPROV_GetStatus Returns System Wi-Fi Provisioning service status ",
							" Setup functions Summary Name Description SYS_WIFIPROV_Tasks Maintains the Wi-Fi Provisioning System tasks and functionalities SYS_WIFIPROV_CtrlMsg Request Wi-Fi Provisioning system service control request interface ",
							" SYS_WIFIPROV_CTRLMSG Enum ",
							" C typedef enum { /* Requesting a Wi-Fi Configuration set(for connect) */ SYS_WIFIPROV_SETCONFIG = 0 /* Requesting a Wi-Fi configuration get */ SYS_WIFIPROV_GETCONFIG /* Updating Wi-Fi Connect status for enabling Wi-Fi Provisioning service */ SYS_WIFIPROV_CONNECT } SYS_WIFIPROV_CTRLMSG ; ",
							" Summary Identifies the control message for which the client has called the SYS_WIFIPROV_CtrlMsg() ",
							" Description Identifies the control message for which the client has called the SYS_WIFIPROV_CtrlMsg() ",
							" Remarks The different control messages which can be invoked by the client ",
							" SYS_WIFIPROV_RESULT Enum ",
							" C typedef enum{ /* Operation completed with success */ SYS_WIFIPROV_SUCCESS = 0 /* Operation failed */ SYS_WIFIPROV_FAILURE /* Operation request object is invalid */ SYS_WIFIPROV_OBJ_INVALID=255 }SYS_WIFIPROV_RESULT; ",
							" Summary Result of a Wi-Fi Provisioning system service client interface operation ",
							" Description Identifies the result of Wi-Fi Provisioning service operations ",
							" Remarks None ",
							" SYS_WIFIPROV_MODE Enum ",
							" C typedef enum { /* Requesting a operating mode as a station */ SYS_WIFIPROV_STA = 0 /* Requesting a operating mode as a access point */ SYS_WIFIPROV_AP = 1 } SYS_WIFIPROV_MODE ; ",
							" Summary Identifies the Wi-Fi operating mode ",
							" Description Identifies the Wi-Fi operating mode ",
							" Remarks Client need to manually reboot device after switching mode For example changing operating mode from STA to AP or AP to STA ",
							" SYS_WIFIPROV_STATUS Enum ",
							" C typedef enum { /* Wi-Fi Provisioning system service is in MPFS filesystem mount state */ SYS_WIFIPROV_STATUS_MPFS_MOUNT=1 /* Wi-Fi Provisioning system service is in NVM read state */ SYS_WIFIPROV_STATUS_NVM_READ /* Wi-Fi Provisioning system service is in NVM read Wi-Fi Configuration checking state */ SYS_WIFIPROV_STATUS_CONFIG_CHECK /* Wi-Fi Provisioning system service is in NVM erase state */ SYS_WIFIPROV_STATUS_NVM_ERASE /* Wi-Fi Provisioning system service is in NVM write state */ SYS_WIFIPROV_STATUS_NVM_WRITE /* Wi-Fi Provisioning system service is in wait for NVM write to complate state */ SYS_WIFIPROV_STATUS_WAITFORWRITE /* Wi-Fi Provisioning system service is in client request state */ SYS_WIFIPROV_STATUS_WAITFORREQ /*Wi-Fi Provisioning system service is in invalid state */ SYS_WIFIPROV_STATUS_NONE =255 } SYS_WIFIPROV_STATUS; ",
							" Summary Result of a Wi-Fi Provisioning system service client interface get operation(SYS_WIFIPROV_GetStatus()) ",
							" Description Result of a Wi-Fi Provisioning system service client interface get operation(SYS_WIFIPROV_GetStatus()) ",
							" Remarks None ",
							" SYS_WIFIPROV_AUTH Enum ",
							" C typedef enum { /* Requesting a Open Authentication types */ SYS_WIFIPROV_OPEN = 1 /* Requesting a WEP Authentication types */ SYS_WIFIPROV_WEP /* Requesting a WPA/WPA2(Mixed) Authentication types */ SYS_WIFIPROV_WPAWPA2MIXED /* Requesting a WPA2 Authentication types */ SYS_WIFIPROV_WPA2 /* Requesting a WPA2/WPA3(Mixed) Authentication types */ SYS_WIFIPROV_WPA2WPA3MIXED /* Requesting a WPA3 Authentication types */ SYS_WIFIPROV_WPA3 } SYS_WIFIPROV_AUTH ; ",
							" Summary Identifies the type of Authentication requested ",
							" Description Identifies the type of Authentication requested ",
							" Remarks None ",
							" SYS_WIFIPROV_CONFIG Struct ",
							" C typedef struct { /* Operating mode of device */ SYS_WIFIPROV_MODE mode; /* Flag to identify if configuration needs to be saved in NVM 0 - Do not save configuration in NVM 1 - Save configuration in NVM */ uint8_t saveConfig; /* Country Code configuration */ uint8_t countryCode[6]; /* Wi-Fi station mode configuration */ SYS_WIFIPROV_STA_CONFIG staConfig; /* Wi-Fi access point mode configuration */ SYS_WIFIPROV_AP_CONFIG apConfig; }SYS_WIFIPROV_CONFIG; ",
							" Summary Configuration of device configuration parameters ",
							" Description Configuration of device configuration parameters ",
							" Remarks None ",
							" SYS_WIFIPROV_AP_CONFIG Struct ",
							" C typedef struct { /* Wi-Fi access point mode SSID */ uint8_t ssid[32]; /* Wi-Fi access point mode passphrase */ uint8_t psk[64]; /* Wi-Fi access point mode authentication type */ SYS_WIFIPROV_AUTH authType; /* Wi-Fi access point mode channel number values of channel: 1 to 13 - operating channel of access point */ uint8_t channel; /* Wi-Fi access point mode SSID visibility Value of ssidVisibility: 0 - Hidden SSID 1 - broadcast the SSID */ bool ssidVisibility; } SYS_WIFIPROV_AP_CONFIG; ",
							" Summary Configuration of access point mode parameters ",
							" Description Configuration of access point mode parameters ",
							" Remarks None ",
							" SYS_WIFIPROV_STA_CONFIG Struct ",
							" C typedef struct { /* Wi-Fi station mode SSID */ uint8_t ssid[32]; /* Wi-Fi station mode passphrase */ uint8_t psk[64]; /* Wi-Fi station mode authentication type */ SYS_WIFIPROV_AUTH authType; /* Wi-Fi station mode channel number values of channel: 0 - scan and connect to all the channels 1 to 13 - - scan and connect to specified channel */ uint8_t channel; /* Wi-Fi station mode auto connect flag value 0- Don't connect to AP wait for client request value 1- Connect to AP */ bool autoConnect; } SYS_WIFIPROV_STA_CONFIG; ",
							" Summary Configuration of station parameters ",
							" Description Configuration of station parameters ",
							" Remarks None ",
							" SYS_WIFIPROV_CALLBACK Typedef ",
							" C typedef void (*SYS_WIFIPROV_CALLBACK )(uint32_t event void * data void *cookie ); ",
							" Summary Pointer to a Wi-Fi Provisioning system service callback function ",
							" Description This data type defines a pointer to a Wi-Fi Provisioning service callback function Callback functions can be registered by client at initializing ",
							" Precondition None ",
							" Parameters Param Description event A event value event can be any of SYS_WIFIPROV_CTRLMSG types data Wi-Fi Provisioning service Data cookie Client register cookie ",
							" Returns None ",
							" Example void WiFiProvServCallback (uint32_t event void * data void *cookie ) { switch(event) { case SYS_WIFIPROV_SETCONFIG: { SYS_WIFIPROV_CONFIG* wifiProvConfig = (SYS_WIFIPROV_CONFIG *) data; // Provisioning service updated data SYS_CONSOLE_PRINT(\"%s:%d Device mode=%d r n\" __func__ __LINE__ wifiProvConfig- mode); break; } case SYS_WIFIPROV_GETCONFIG: { SYS_WIFIPROV_CONFIG* wifiProvConfig = (SYS_WIFIPROV_CONFIG *) data; // client requested get Wi-Fi Configuration SYS_CONSOLE_PRINT(\"%s:%d Device mode=%d r n\" __func__ __LINE__ wifiProvConfig- mode); break; } } } ",
							" Remarks None ",
							" SYS_WIFIPROV_CtrlMsg Function ",
							" C SYS_WIFIPROV_RESULT SYS_WIFIPROV_CtrlMsg (SYS_MODULE_OBJ object uint32_t event void *buffer uint32_t length ) ",
							" Summary Request Wi-Fi Provisioning system service control request interface ",
							" Description This function is used to make control request to Wi-Fi Provisioning system service ",
							" Precondition The SYS_WIFIPROV_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFIPROV object handle returned from SYS_WIFIPROV_Initialize event A event value event can be any of SYS_WIFIPROV_CTRLMSG types buffer Control message data input length size of buffer data ",
							" Returns return SYS_WIFIPROV_RESULT ",
							" Example Details of SYS_WIFIPROV_SETCONFIG: SYS_WIFIPROV_CONFIG wifiProvConfig; SYS_MODULE_OBJ wifiProvServHandle; // Set mode as STA wifiProvConfig mode = SYS_WIFI_STA; // Disable saving wifi configuration wifiProvConfig saveConfig = false; // Set the auth type to SYS_WIFI_WPA2 wifiProvConfig staConfig authType = SYS_WIFI_WPA2; // Enable all the channels(0) wifiProvConfig staConfig channel = 0; // Device doesn't wait for user request wifiProvConfig staConfig autoConnect = 1; // Set SSID memcpy(wifiProvConfig staConfig ssid WIFI_DEV_SSID sizeof(WIFI_DEV_SSID)); // Set PSK memcpy(wifiProvConfig staConfig psk WIFI_DEV_PSK sizeof(WIFI_DEV_PSK)); if (SYS_WIFIPROV_OBJ_INVALID = SYS_WIFIPROV_CtrlMsg (wifiProvServHandle SYS_WIFIPROV_SETCONFIG wifiProvConfig sizeof(SYS_WIFIPROV_CONFIG))) { // When Wi-Fi Provisioning Configuration need to be updated } Details of SYS_WIFIPROV_GETCONFIG: SYS_WIFIPROV_CtrlMsg (wifiProvServHandle SYS_WIFIPROV_GETCONFIG NULL 0); Details of SYS_WIFIPROV_CONNECT: // Updating Wi-Fi Connected state to Provisioning service bool wifiProvConnectState = true; SYS_WIFIPROV_CtrlMsg (wifiProvServHandle SYS_WIFIPROV_CONNECT wifiProvConnectState sizeof(wifiProvConnectState)); // Updating Wi-Fi disconnected state to Provisioning service bool wifiProvConnectState = false; SYS_WIFIPROV_CtrlMsg (wifiProvServHandle SYS_WIFIPROV_CONNECT wifiProvConnectState sizeof(wifiProvConnectState)); ",
							" Remarks None ",
							" SYS_WIFIPROV_Deinitialize Function ",
							" C SYS_WIFIPROV_RESULT SYS_WIFIPROV_Deinitialize (SYS_MODULE_OBJ object) ",
							" Summary Deinitializes the module instance of the SYS WIFIPROV module ",
							" Description This function deinitializes the module instance disabling its operation Resets all of the internal data structures and fields to the default settings ",
							" Precondition The SYS_WIFIPROV_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFIPROV object handle returned from SYS_WIFIPROV_Initialize ",
							" Returns return SYS_WIFIPROV_RESULT ",
							" Example if (SYS_WIFI_SUCCESS == SYS_WIFIPROV_Deinitialize (wifiProvServHandle)) { // when the SYS WIFI is De-initialized } ",
							" Remarks Deinitialize should be called if the WiFi Provisioning service is no longer going to be used ",
							" SYS_WIFIPROV_GetStatus Function ",
							" C uint8_t SYS_WIFIPROV_GetStatus ( SYS_MODULE_OBJ object) ",
							" Summary Returns System Wi-Fi Provisioning service status ",
							" Description This function returns the current status of the System Wi-Fi Provisioning service ",
							" Precondition The SYS_WIFIPROV_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFIPROV object handle returned from SYS_WIFIPROV_Initialize ",
							" Returns return SYS_WIFIPROV_STATUS if client provided object is valid else return SYS_WIFIPROV_OBJ_INVALID ",
							" Example if (SYS_WIFIPROV_STATE_WAITFORREQ == SYS_WIFIPROV_GetStatus (wifiProvServHandle)) { // when the SYS WIFI Provisioning module in wait for client request } ",
							" Remarks None ",
							" SYS_WIFIPROV_Initialize Function ",
							" C SYS_MODULE_OBJ SYS_WIFIPROV_Initialize ( SYS_WIFIPROV_CONFIG *config SYS_WIFIPROV_CALLBACK callback void *cookie ) ",
							" Summary Initializes the System Wi-Fi Provisioning module ",
							" Description Wi-Fi Provisioning service supports only single instance ",
							" Parameters Param Description config Wi-Fi Provisioning device configuration structure callback The client callback function pointer cookie The pointer which will be passed to the client application when the client callback function is invoked ",
							" Returns If successful returns a valid handle to an object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example #define WIFI_DEV_SSID \"DEMO_AP\" #define WIFI_DEV_PSK \"password\" SYS_WIFIPROV_CONFIG wifiProvConfig; SYS_MODULE_OBJ wifiProvServHandle; // Set mode as STA wifiProvConfig mode = SYS_WIFI_STA; // Disable saving wifi configuration wifiProvConfig saveConfig = false; //Set the auth type to SYS_WIFI_WPA2 wifiProvConfig staConfig authType = SYS_WIFI_WPA2; // Enable all the channels(0) wifiProvConfig staConfig channel = 0; // Device doesn't wait for user request wifiProvConfig staConfig autoConnect = 1; // Set SSID memcpy(wifiProvConfig staConfig ssid WIFI_DEV_SSID sizeof(WIFI_DEV_SSID)); // Set PSK memcpy(wifiProvConfig staConfig psk WIFI_DEV_PSK sizeof(WIFI_DEV_PSK)); wifiProvServHandle = SYS_WIFIPROV_Initialize( wifiProvConfig WiFiProvServCallback 0); if (wifiProvServHandle == SYS_MODULE_OBJ_INVALID) { // Handle error } ",
							" Remarks Client can auto enable the Provisioning service functionality by selecting MHC configuration option of Wi-Fi Service ",
							" SYS_WIFIPROV_Tasks Function ",
							" C uint8_t SYS_WIFIPROV_Tasks ( SYS_MODULE_OBJ object) ",
							" Summary Maintains the Wi-Fi Provisioning System tasks and functionalities ",
							" Description This function is used to run the various tasks and functionalities of Wi-Fi Provisioning system service ",
							" Precondition The SYS_WIFIPROV_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS WIFI Provisioning object handle returned from SYS_WIFIPROV_Initialize ",
							" Returns return SYS_WIFIPROV_STATUS if client provided object is valid else return SYS_WIFIPROV_OBJ_INVALID ",
							" Example if (SYS_WIFIPROV_OBJ_INVALID = SYS_WIFIPROV_Tasks (wifiProvServHandle)) { } ",
							" Remarks None ",
							" Wi-Fi provisioning System Service Developer's Guide ",
							" Code modification/implementation guide for common use cases ",
							" **Adding New provisioning Method ** When User want to add new provisioning method user needs to parse the incoming provisioning data and update the information in SYS_WIFI_CONFIG as shown in below code snippet The Wi-Fi provisioning Service stores and maintains the Wi-Fi configuration data if NVM is enabled by user in the MHC SYS_WIFI_CONFIG wifiSrvcConfig; // Set mode as STA wifiSrvcConfig mode = SYS_WIFI_STA; // Enable saving wifi configuration wifiSrvcConfig saveConfig = true; // Set the auth type to SYS_WIFI_WPA2 wifiSrvcConfig staConfig authType = SYS_WIFI_WPA2; // Enable all the channels(0) wifiSrvcConfig staConfig channel = 0; // Device doesn't wait for user request wifiSrvcConfig staConfig autoConnect = 1; // Set SSID memcpy(wifiSrvcConfig staConfig ssid WIFI_DEV_SSID sizeof(WIFI_DEV_SSID)); // Set PSK memcpy(wifiSrvcConfig staConfig psk WIFI_DEV_PSK sizeof(WIFI_DEV_PSK)); if (SYS_WIFI_SUCCESS == SYS_WIFI_CtrlMsg (sysObj syswifi SYS_WIFI_CONNECT wifiSrvcConfig sizeof(SYS_WIFI_CONFIG))) { } ",
							" Over The Air (OTA) firmware update System Service OTA System Service Library provides an application programming interface (API) to manage OTA functionalities The OTA System Service uses the Wi-Fi service Net service NetPres APIs for achieving these functionalities The user would need to configure the Home AP credentials (like SSID and Passphrase) The Wi-Fi service will use the credentials to connect to the Home AP and acquire an IP address Once the IP address is obtained service will perform OTA update process based on OTA service configurations ",
							" Key Features External Flash based OTA OTA images will be stored in a filesystem hosted on an External flash An OTA database d MHC file system) is maintained in the external flash to manage images OTA download during application execution When an updated image is available it will be downloaded in the background while customer application is running without disturbing any processes executing in the system The application can optionally chose when the download should start Opt when to switch to new image Customer application can decide when it should switch to the new image This lets the current application gracefully shutdown services and apply the update at a later point Trigger firmware update via a single API OTA service can be configured to work in daemon mode where the system service performs periodic update checks and auto-restart once a valid image is downloaded It can also be configured to asynchronously trigger a firmware update via a single API call Firmware update trigger from device or external sources OTA update checks can be triggered via external source if not configured for periodic checks Opt for Secure OTA The user can opt to perform the OTA image download and update in a secure way using TLS connection and image signatures The OTA System Service provides simple APIs to enable OTA functionality More information is provided in the following sections ",
							" OTA System Service Usage ",
							" Description The OTA System Service provides simple APIs to enable Over the Air system firmware image upgrade While using the service the application does not have to handle low level states of a TCP/IP Connection periodic update check triggers file integrity checks etc since the service internally takes care of that The user also does not required extensive Security domain knowledge to establish a secured connection via the application using OTA System Service library The user would need to configure the Home AP credentials (like SSID and security items) The Wi-Fi service will use the credentials to connect to the Home AP and acquire an IP address Once the IP address is obtained OTA service will perform OTA update process based on user configuration in MHC resized_wifi_sta_http_server_1 The service state-machine will try to connect with a pre-defined OTA manifest server address and download the new image when a version higher than the version being currently executed is identified The downloaded image will be stored in the external SPI flash initially Upon reset the image will be transferred to the internal flash (NVM) by the OTA bootloader Once the image is successfully programmed the updated image from the server will be executed The OTA service has two major components: 1 The OTA service task state-machine that will be integrated into the customer application This task is responsible for polling for an update image downloading and verifying an image when an update is detected and resetting the system to apply the newly downloaded image 2 The OTA bootloader that is responsible for identifying the presence of an updated image in the external flash filesystem and transferring it to the program flash memory (NVM) A factory image is a unified application image that contains the bootloader and the application in a single file that can be programmed into the device using an external programmer To create a factory image it is required to load the ota_bootloader project located in the apps folder of wireless_apps_pic32mzw1_wfi32e01 repo into the application project A unified hex file will be created at the end of the compilation process Internally this step uses the Hexmate tool after compiling the application project and the bootloader project independently More details about this can be found in OTA System Service Configuration section of this manual OTA service uses the file system component from MHC (MPLAB® Harmony Configurator) and is configured to use an external SPI flash by default However this can be modified to use a different medium without major changes since the OTA service uses the file system abstraction to talk to the external storage medium An OTA image database is maintained by the service in the filesystem It contains details about the downloaded images (image name image status image version digest key) which will be used by bootloader and OTA service SPI_com ",
							" OTA Service Framework Architecture Overview Over the Air (OTA) firmware upgrade feature is designed with a two step process Image Downloading and Image Programming process Image Downloading is processed by the OTA service Image Programming is processed by the OTA bootloader OTA service is a Harmony component which includes the system level logic implementation and uses OTA core APIs This harmony component will provide some user configurable parameters based on which service level code will be generated with the corresponding logic Please follow Figure-1 and Figure-2 for better understanding of this flow system_layers top_to_bottom_layers ",
							" Abstraction model abstraction_model User Application: This is where the customer application logic is built OTA Service: This layer includes the service level logic implementation This is a Harmony component which provides certain user configurable parameters(ex- Version Periodic update check etc ) Based on user configuration generated code will be activated with required functionalities ota_service_component ota_service_conf OTA software platform / OTA Core : This is the platform layer that consist of the main OTA logic implementation When OTA process is triggered this layer will communicate with the transport layer to connect to OTA server If new image is available it will initiate download using transport layer If successfully downloaded it will store the new image into the File System File System : The architecture is designed to provide flexibility for the customer to choose the storage medium (ex- SST26 SPI flash SD card USB MSD in host mode etc ) Any medium supported by the Harmony3 file system can be used with the OTA service Bootloader : This layer consists of the logic to safely program images from the file system (external) into the program memory (NVM) of the device At device boot the bootloader will check if a new image is available in the external image store and transfer it to the NVM ",
							" OTA server JSON manifest The OTA service expects the HTTP based OTA server to provide metadata of images available in the server in json format During periodic update checks the OTA service task will download and parse this manifest file Each entry in the manifest file should include the following fields : Version indicates the application version number It is a integer value URL contains the image path from which the application image can be downloaded It is a string variable Digest contain the SHA256 digest of image to be downloaded It is a 64 byte string variable and should not include whitespaces EraseVer This optional field provides a capability to trigger an erase of an version which was downloaded earlier Customer may want to remove an image from the image store due to various reasons application with bug may be one of them It is a bool variable If user configures this field as \"true\" OTA service will delete image version mentioned in \"Version\" field If user configures this field as \"false\" OTA service will follow image downwload logic Patch This optional field provides a facility to support patch functionality If patch functionality-option is enabled in the project application will try to fetch below fields BaseVersion This is base image version against which patch will be applied Application will check the presence of this base image version in OTA DB present in external flash BaseVerDigest Base image digest must be provided by user which will be used by application to verify correct Base image This digest will be compared against the digest (stored inside OTA DB) of base version PatchURL URL-path of patch image PatchDigest Digest of Patch image This is used by the application in the device to verify downloaded patch image TargetDigest Digest of the Target image obtained after applying Patch This is used by the application in the device to verify target image obtained after applying patch functionality Sample JSON { \"ota\": [ { \"Version\": 5 \"URL\": \"http://192 168 0 101:8000/wifi_ota_app_upgrade_ver2 bin\" \"Digest\": \"aff0d6d02fabf6a8cc96f762eb71f54f3687ce7d8605dd814055c17eface0b1d\" \"EraseVer\": false \"Patch\" : [ { \"BaseVersion\": 1 \"BaseVerDigest\": \"aff0d6d02fabf6a8cc96f762eb71f54f3687ce7d8605dd814055c17eface0b1d\" \"PatchURL\": \"http://192 168 0 101:8000/wifi_ota_app_upgrade_patch patch\" \"PatchDigest\": \"266008c4a6150d7033e370a48621ecd44985b3d0418cdf13bbb6efa6fae43823\" \"TargetDigest\": \"beac75ef53f0159cae0645c32f58a9705d237823607c6e65267ca61793dfcb08\" } ] } ] } OTA service will download json file from server first when OTA process is triggered try to fetch information and proceed further as per below logic: resized_json_parse_logic ",
							" Factory Image Structure The program memory of an application that include the OTA service will be organized as shown in the image below Application_Image3 ",
							" Application Header Structure (boot control area) A boot control area of size 4 KB is maintained in internal flash area of device as a shared memory between the application and the bootloader This area will contain fields as shown in figure below ota_header ",
							" Image download process 1 The OTA service task identifies that the server manifest includes an image with a version number numerically higher than the current version being executed in the system Image version number is a C macro that can be defined in MHC 2 The transport layer starts downloading the image using the link in the URL If the URL starts with an https:// TLS is automatically used 3 Once the download is completed successfully the OTA framework verifies the image by checking the SHA-256 hash once transport layer finished receiving all data If download fails system will go to IDLE If Auto Update is enabled user need to reset the device to initiate OTA again 4 If image digest verification is failed user will be notified using user registered callback If image digest verification is passed OTA framework will create an entry in OTA database present in external filesystem OTA database is maintained in csv format Each entry in the OTA database will contain following information: a image name: name of downloaded image b image status: This will be set as 0xFE for newly downloaded image c version number: Version number of image obtained from JSON manifest d image digest: Image digest obtained from JSON manifest 5 Once entry is made successfully OTA framework updates Boot-Control-header status field of the current application to “Disabled” 0xF0 User will be notified about successful OTA process via user registered callback and wait for system reset or trigger auto system reset based on MHC configuration to load new image into the program flash memory ",
							" Block/Flow Diagram a OTA Service: resized_otaservice_flowchart OTA Start: OTA process can be triggered using various methods : Periodically : System will communicate with OTA server periodically (configured by user) to check if any new image is available and initiate OTA process accordingly Manually : OTA can be triggerred by the application by calling an API Other sources : User may configure/implement any other means of source like MQTT server to trigger OTA This is a subset of the manual triggers Download JSON manifest file and check for version : JSON file will be downloaded from server first once OTA process is initiated JSON file will have version number along with other details Now system will try to compare the extracted version number from JSON file with currently running application version number and decide accordingly the next step : If version number is same abort the OTA process because new image is not available If version number is different and higher than the current application version number then system will continue with OTA process Patch Functionality : If patch functionality is enabled in the application it will try fetch relative information from JSON manifest and proceed accordingly Initiating image Download process : Based on user configuration system will go for image downloading or will wait for download trigger by user Digest verify : SHA-256 verification will be done for downloaded image Update OTA database file system : If digest verification is successful OTA database will be updated in file system for new image Storing image in the external flash and wait : If downloaded successfully the image will be stored in the external flash using standard FS present in Harmony Afterwards system will perform following steps depending upon user configuration : reset automatically if Auto reset option is enabled wait till user application triggers reset b Image Programming: resized_bootloader_flowchart 1 During each system boot-up bootloader checks if it needs to program any new valid image from the external flash Bootloader goes to program mode if- 1 any newly downloaded image present in the external flash 2 if the already present image in the program flash is not \"validated\" during previous boot There are two conditions : whether the Application Image in Program-Flash area is valid (indicated by the STATUS field value of 0xF8 in image boot control area of internal flash) and whether it has been confirmed that no errors were present during the previous boot (indicated by the STATUS field of image Database in the external flash value of 0xF8 ) According to bootloader logic if these two conditions are satisfied it will not go to Program Mode and the bootloader immediately jumps to the application image present in the program-flash area of the device 2 If two conditions mentioned in the step 1 are not satisfied the bootloader switches to Image Program Mode In Image Program Mode bootloader follows Image Programming sequence which finds the highest ranked image in Image-Store(external flash) erases the Program-Flash area and copies the selected image to the Program-Flash area if the image is successfully verified As the newly downloaded image with highest version is set as the highest ranked during the first boot time after the Image-downloading the bootloader attempts to load the newly downloaded image at the first try The bootloader choses the highest ranked image to boot The images are ranked in following order: 1 The downloaded valid Image with highest version 2 The next valid higher version image 3 The next known valid higher version image 4 Default (Golden/Factory) image 3 If the image is not valid the bootloader invalidates the image by setting “Invalidate” 0xF0 in STATUS field of image in OTA database present in the external flash and restarts the Image-Programming sequence 4 If image is verified successfully bootloader updates STATUS field of boot control area in internal flash as Unbooted (0xFC) ",
							" Patch functionality OTA service provides facility of patch OTA User can configure PATCH functionality using MHC menu for more details on configuration please follow - OTA System Service Configuration section Patching is a concept using which user can generate a binary file that contains only the difference between the current image and base image version For generating diff file user can download utility(jojodiff07) and follow instructions from here Other versions of the jojodiff utility may lead to compatiblity issues and may cause failure in the OTA patch update Therefore it is recommended to use the jojodiff07 version for creating the diff file User can provide required parameters for patch in JSON file ( Please follow OTA server JSON manifest section for more details ) OTA Service will follow below steps during while processing patch functionality : Check if base version is present in OTA DB If not present sysetm will try to download full image from server If present system will proceed with logic for patch functionality During patching system will at first verify downloaded patch image using SHA-256 If patch file is verified successfully system will generate target binary image After successful generation of target image SHA-256 verification will be done against target image If target image is verified successfully same will be stored in OTA DB present in the external flash Finally new image will be applied by bootloader as per application logic resized_patch_details ",
							" Securing OTA by verifying Images in Bootloader Images will be verified by using image's ECDSA signature on Bootloader For this user need to provide image's signature generated in R-S format to Signature field of JSON manifest file (Please follow Generating Signature section of this document) This Signature will be stored by application in ota database present in external flash and bootlader will use the same for image verification We have implemented 2 configurations of OTA Bootloader to perform signature verification of images: In software using Wolfcrypt (ota_booloader_wolfcrypt x) In Hardware using Trust Flex device (ota_booloader_trustflex x) For more information on ota bootloader please follow Bootloader document User need to load the corresponding bootloader configuration as loadable component as per application requirement Loading bootloader into application is required only for generating factory image For more information on configuring loadable project please refer OTA System Service Configuration section of Configuring the library  Whenever user wants to apply successfully downloaded new ota image bootloader will take the control Bootloader will perform signature verification of the image : if signature verfication is failed; Bootloader will try to load another version of OTA image if present in OTA database If bootloader can not find another image it will load the factory image to the internal flash if signature verification is passed; bootloader will load the image after successfully verifying digest NOTE : Secure OTA is not supported when PATCH functionality is enabled ",
							" Enabling Secure OTA By default secure ota option will be disabled To enable it user need to follow below steps Enable Secure OTA Functionality as described in configure Advances Configuration section of Configuring the library  Define \"SYS_OTA_SECURE_BOOT_ENABLED\" in bootloader project For more details please follow Bootloader document  ",
							" Verification of factory image For verification of factory image user need to follow below steps : User need to create \" bin\" format of HEX image created while building factory image using MPLABX User need to use following command: python hex2bin py -i \"path of hex image\" -o \"path of bin file\" -f 0 example : python hex2bin py -i \"E: ota_new_festeure factory_image_verification hex2bin factory_image hex\" -o \"E: ota_new_festeure factory_image_verification hex2bin factory_image1 bin\" -f 0 hex2bin py file can be found in the tools folder of your project This folder will be created when you generate MHC code with the OTA service included in your project Generate signature by followinf Generating Signature section of this document Store the generated signature in target system using following console command (Factory image should already be loaded in the system and factory image should be running): sysota set factory sign \"signature\" example : sysota set factory sign \"FkV6dJ9kMqJrJypp/0/V8MdIV4Y6ocNX5NVb5zvwDa2ygXJsVHDQZGCNR/L0lp13xroX9biwMBbpi/ZqJi1Erw==\" NOTE : 1 It is recommended to perform above mentioned steps and store signature in target device as soon as application runs for the first time This will ensure safe and successful loading of factory image in the system whenever required This is one time activity 2 If factory reset is triggered without storing signature of factory image system will unable to load image and run ",
							" Generating Public Key and Private Key To generate private key : openssl ecparam -genkey -name prime256v1 -noout -out ECC_prime256v1 key To extract public key from certificate : openssl exe ec -in ECC_prime256v1 key -pubout -out ECC_prime256v1 pub ",
							" Generating Signature User need to generate signature in R-S format and provide it in manifest file To generate R-S format of image signature user may take any approach; example: using openssl library etc Alternately user may use python script ecdsaSign py present in the tools folder of project This folder will be created when user generates MHC code with the OTA service included in project User may use below command for generating signature : python ecdsaSign py -f [image file name] -k [private key file name] Example : python sign py -f image bin -k ECC_prime256v1 key image bin - image file name ECC_prime256v1 key - private key file name ",
							" Providing Signature in Manifest file: User need to mention Signature in Manifest file by introducing Signature field in the file as shown below: { \"ota\": [ { \"Version\": 2 \"URL\": \"http://192 168 43 173:8000/wifi_ota_app_upgrade_ver2 bin\" \"Digest\": \"d6f951e9ad5af844068a3ce1cc25e86ac945fa371791ca3e493f91672d95a2d4\" \"Signature\": \"pra2wlOiZO/zjzqaP9DZGe9dmm0aC4gx4r0yoyI7DU3sVpkdJ034v5XoiN5jdpeuLRge4RjsB/KSrVho8pwC2w==\" \"EraseVer\": false } ] } ",
							" Provisioning TrustFlex parts for OTA FW Verification ATECC608 based Trustflex can be used to perform secure firmware verification The steps to provision it using TPDS2 is documented here Setup TPDS V2 Setup TPDSV2 following the steps at https://www microchip com/en-us/product/SW-TPDSV2 Make sure that you update TPDS after installation Hardware Setup Plug in the DT100104 click board into the microbus interface Make sure that you flip all DIP switches other than SW1:2 in click board to OFF position This will configure the board to expose the TrustFlex device over the I2C Bus trust_flex_image1 Device Firmware TPDS talks to the trust elements using the KitProtocol So before using TPDS to provision TrustFlex with the Rio2 device we need to flash the KitProtocol firmware into the dev-board To update the kit-protocol firmware to use I2C1 instead of the default I2C2 (connected to the onboard TnG module) change HAL_I2C_I2C2 defined in hal_i2c_harmony h file of the kit protocol project to HAL_I2C_I2C1 When the firmware boots-up the UART console (15008N1) will display the devices detected trust_flex_image2 trust_flex_image3 Loading the Public Key for FW verification (Provisioning) Open TPDS and select ATECC608-TFXTLS configurator under the \"Configurators\" Tab SelectTrustFlexConfigurator Select the Firmware Validation (Secure Boot) usecase from the next screen trust_flex_image5 Load the public key into Slot 15 trust_flex_image6 Generate a provisioning package and use it to provision the sample The attached kit with the trustFlex device mounted on it will be automatically detected and provisioned trust_flex_image7 trust_flex_image8 You can now use the device to verify image signatures in the bootloader ",
							" Configuration fuses Due to the way configuration fuses are stored in the device they cannot be modified by the bootloader at runtime Consequently when the bootloader loads the application the config fuses set in the bootloader (using #pragma in the bootloader code) will be retained Unlike most of the other PIC32MZ devices some of the configuration values of PCI32MZW1 / WFI32 can be overridden at runtime These are marked as loadable configurations in the datasheet Please refer to the Configuration Bits section of the SPECIAL FEATURES chapter of the PIC32MZW1 datasheet to see a list of loadable configurations and how to apply them These loadable configs can be applied at runtime from the application ",
							" Generating the OTA image Images that are downloaded from the server as part of the OTA process should be stored in bin format as opposed to the Intel Hex format that is generated by MPLABX To convert the hex file to bin format you can use the hex2bin tool in the tools folder of your project This folder will be created when you generate MHC code with the OTA service included in your project In case of a windows machine you can execute the command hex2bin exe -i path to hex file in the dist folder In case your development environment is based on a non-Windows OS you can execute the python script with the same arguments Make sure that you have python3 installed in your machine User may execute hex2bin tool directly from tools folder without any argument In that case tool will search for hex file in default path \" project X dist project production\" and generate bin file User may also execute post build command / /tools/hex2bin/hex2bin exe from MPLABx project itself : Right click on the project and click on properties project_loading Select \"building\" insert below command and click \"OK\": / /tools/hex2bin/hex2bin exe Note : python should be present in the system variable path resized_post_build ",
							" OTA server Any standard http/https server can be used as OTA server as long as it hosts a manifest file with the mandatory fields For testing the service you may also use a simple python command to create a local HTTP server using below steps: Open command prompt and change directory to the folder where json file/ota image is present resized_Change_dir Use below python command in command prompt: python -m SimpleHTTPServer 8000 resized_http_server ",
							" Integrating bootloader It is required to integrate the bootloader and OTA application image to create a single unified HEX file To integrate 2 images we can use hexmate tool which is readily available with MPLABX package as part of the standard installation To combine the hex files - please follow steps mentioned in configuration page OTA System Service Configuration  ",
							" Resolving Data Conflict Compilation error During compilation if user is facing Data conflict at address compilation error please check if there is any mismatch of configuration ( #pragma ) between bootloader and application User may simply compare initialization c files of both the projects to check mismatch resized_pragma_mismatch ",
							" OTA System Service Configuration The OTA System Service library should be configured through the MHC ( MHC configuration is initial configuration some of parameters can be changed runtime using respective APIs - follow OTA System Service Interface ) When user selects the OTA System Service library all the required dependencies components are added automatically in the MHC configuration The following figure shows the MHC configuration window for configuring the OTA System Service and a brief description of various configuration options 1 Open the MHC 3 2 Drag the OTA Service Module into the Active components from the Available components ota_service_MHC 3 Configure the various parameters ota_config 4 configure Auto reset : ota_config_autoreset By default this option will be enabled System will reset automatically after successful download of OTA image to load new image into the system and run without any notifications to the current application If it is disabled by user system will not go for reset automatically Instead it will be waiting for user trigger for system reset 5 configure server URL : ota_config_serverurl User need to provide the server url where the manifest file in json format is available OTA service will use this url to connect to server and download json file to check for updates 6 configure Auto OTA update : ota_config_autoupdate By default this option will be enabled If it is enabled OTA service will not wait for user trigger to initiate OTA process It will automatically start OTA process if new update is available in the server If it is disabled OTA service will wait for user trigger to initiate OTA process User will be notified about new update availability via user defined callbacks 7 configure Periodic OTA check : ota_config_periodiccheck By default this option will be configured to 60 seconds When enabled OTA service will periodically download the manifest file to check for update availability at the user defined interval If it is disabled OTA service will be checking for update availability on user trigger via the control message API 8 configure Application version : ota_config_appversion User must ensure to provide correct integer version while generating OTA image This version number should be also be mentioned in the manifest file in OTA server OTA upgrade will be triggered when a version with numerically higher version number is identified in the manifest file 9 configure Advanced Configuration : AdvancedConfig_OTA Number of images: This configuration controlled the number of OTA images to be stored in the filesystem If number of images downloaded via OTA process exceeds this number user will be notified with a console message and the oldest image in the database will be replaced with newly downloaded image automatically This count excludes the factory reset image that will be backed-up to the filesystem by the bootloader at first boot Set JSON file size in bytes: Maximum size (in bytes) of the json file present in the server Enable TLS: By default this option will be disabled If it is enabled by user service will support TLS connection Based on the server URL prefix ( http:// / https:// )mentioned by user the system will try to download the manifest file Server certificate verification will not be done fo TLS connection if required user needs to explicitly add lines of code for same Enforce TLS: By default this option will be disabled If it is enabled by user service will enforce TLS connection irrespective of the server URL prefix ( http:// / https:// )mentioned by user Server certificate verification will not be done fo TLS connection if required user needs to explicitly add lines of code for same NOTE : If disabled service will automatically detect and go for http or https connection by looking into server URL mentioned by user Disk space check: By default this option will be disabled If enable free sector check will be done in ext flash before download starts Enable/Disable Patch Functionality: By default this option will be disabled If enabled by user OTA service will enable code to support patch functionality Enable/Disable Secure OTA Functionality: By default this option will be disabled If enabled by user OTA service will enable code to support Secure OTA functionality All of the required files are automatically added into the MPLAB X IDE project by the MHC when the OTA Service is selected for use 10 Generate code using \"Generate\" button in MHC : ota_mhc_generate 11 In case you are creating a factory image include the bootloader project from the apps folder of this repo as a loadable project into the application : resized_ota_add_loadables NOTE: Please open bootloader project in MPLABx IDE and compile separately before loading 12 Build the project to get the unified hex and load the same on device ",
							" Building custom logic User can build custom logic required for own design using configrable parameters as mentioned above Additionally users can also build and apply required application level logic which can be included in app c file ",
							" Easily registering user callbacks For making it more flexible and easy for users to register OTA service callbacks OTA service will generate the app_ota c file which contains a skeleton of the callback function definition that can be used to implement business-logic The file also provides an easy to use initialization function that can be invoked from the user application to register these callbacks in case you decide to use them For more details please follow the instructions in OTA System Service Interface section ",
							" OTA System Service Interface ",
							" Data Types and Constants Summary Name Description SYS_OTA_CTRLMSG Identifies the control message for which the client has called the SYS_OTA_CtrlMsg() SYS_OTA_STATUS Provide status of OTA system SYS_OTA_RESULT Result of a OTA system service client interface operation SYS_OTA_Config Used for passing on the configuration related to the OTA service SYS_OTA_DATA This structure holds the system service's data ",
							" Initialization functions Summary Name Description SYS_OTA_Initialize Initialization of data structures of the OTA service ",
							" Setup functions Summary Name Description SYS_OTA_Task Executes the SYS OTA service state machine SYS_OTA_CtrlMsg Returns success/ failure for the control operation asked by the user ",
							" Registering call back function summary Name Description ota_app_reg_cb Registering OTA service callback function ",
							" SYS_OTA_STATES Enum ",
							" C typedef enum { /* Service's state machine's initial state */ SYS_OTA_REGWIFISRVCALLBCK = 0 /* Wait for network connection */ SYS_OTA_WAITFOR_NETWORK_CONNECTION /*Wait for OTA core to be idle*/ SYS_OTA_WAITFOR_OTAIDLE /*Registering OTA callback*/ SYS_OTA_REGOTACALLBCK /*To check if OTA auto update is enabled by user*/ SYS_OTA_AUTO_CONFIGURATION_CHECK /*Check update availability with OTA server*/ SYS_OTA_SERVER_UPDATE_CHECK /*Waiting for timer if OTA is enabled for periodic update check by user*/ SYS_OTA_WAIT_FOR_OTA_TIMER_TRIGGER /*Check update availability with OTA server if OTA auto update is enabled by user*/ SYS_OTA_AUTO_UPDATE_CHECK /*Trigger OTA*/ SYS_OTA_TRIGGER_OTA /*Wait for OTA complete*/ SYS_OTA_WAIT_FOR_OTA_COMPLETE /*To erase image from External File system*/ SYS_OTA_ERASE_IMAGE /*To trigger factory reset*/ SYS_OTA_FACTORY_RESET /*To trigger rollback*/ SYS_OTA_ROLLBACK /*to update user about current service state*/ SYS_OTA_UPDATE_USER /*For resetting system if auto reset is enabled by user*/ SYS_OTA_AUTORESET /*For resetting system on user trigger*/ SYS_OTA_SYSTEM_RESET /*Service Idle state*/ SYS_OTA_STATE_IDLE /*Init state for update check*/ SYS_OTA_UPDATE_CHECK_INIT /*Connecting to server while checking update availability*/ SYS_OTA_UPDATE_CHECK_CNCT_TO_SRVR /*Reading JSON after download*/ SYS_OTA_UPDATE_CHECK_READ_JSON /*Checking JSON content for proper value and mandatory fields */ SYS_OTA_UPDATE_CHECK_JSON_CONTENT /*Complete of OTA update check*/ SYS_OTA_UPDATE_CHECK_DONE /*update check trigger to check update manually using APIs */ SYS_OTA_SERVER_UPDATE_CHECK_TRIGGER /* TODO: Define states used by the application state machine */ } SYS_OTA_STATES; ",
							" Summary Application states enumeration ",
							" Description This enumeration defines the valid application states These states determine the behavior of the application at various times ",
							" SYS_OTA_RESULT Enum ",
							" C typedef enum { /* Operation completed with success */ SYS_OTA_SUCCESS = 0 /* Operation Failed */ SYS_OTA_FAILURE } SYS_OTA_RESULT; ",
							" Summary Result of a ota system service client interface operation ",
							" Description Result of a ota system service client interface operation * ",
							" Remarks None ",
							" SYS_OTA_CTRLMSG Enum ",
							" C typedef enum { /* Control message type for registering a ota system service client callback */ SYS_OTA_REGCALLBACK = 0 /* Control message type for checking OTA update availability */ SYS_OTA_UPDATECHCK /* Control message type for triggering OTA update */ SYS_OTA_INITIATE_OTA /* Control message type for triggering system reset */ SYS_OTA_TRIGGER_SYSTEM_RESET /* Control message type for triggering factory reset */ SYS_OTA_TRIGGER_FACTORY_RESET /* Control message type for triggering Roll back */ SYS_OTA_TRIGGER_ROLLBACK } SYS_OTA_CTRLMSG; ",
							" Summary Identifies the control message for which the client has called the SYS_OTA_CtrlMsg() ",
							" Description Identifies the control message for which the client has called the SYS_OTA_CtrlMsg() ",
							" Remarks The different control messages which can be invoked by the client ",
							" SYS_OTA_STATUS Enum ",
							" C typedef enum { /* To provide status of OTA system */ /*system in idle state*/ SYS_OTA_IDLE = 0 /*waiting for network connection*/ SYS_OTA_WAITING_FOR_NETWORK_CONNECTION /*waiting for OTA core to become IDLE*/ SYS_OTA_WAITING_FOR_OTACORE_IDLE /*waiting for user defined period*/ SYS_OTA_WAITING_FOR_USER_DEFINED_PERIOD /*update check with server start*/ SYS_OTA_UPDATE_CHECK_START /*update check with server failed*/ SYS_OTA_UPDATE_CHECK_FAILED /*update available in server*/ SYS_OTA_UPDATE_AVAILABLE /*update not available*/ SYS_OTA_UPDATE_NOTAVAILABLE /*OTA trigger failed*/ SYS_OTA_TRIGGER_OTA_FAILED /*Factory reset success*/ SYS_OTA_FACTORY_RESET_SUCCESS /*factory reset failed*/ SYS_OTA_FACTORY_RESET_FAILED /*rollback success*/ SYS_OTA_ROLLBACK_SUCCESS /*rollback failed*/ SYS_OTA_ROLLBACK_FAILED /*base image version for patching is not found in OTA DB*/ SYS_OTA_PATCH_BASEVERSION_NOTFOUND /*Patch event initiated*/ SYS_OTA_PATCH_EVENT_START /*Patch event completed*/ SYS_OTA_PATCH_EVENT_COMPLETED /*download start*/ SYS_OTA_DOWNLOAD_START /*download success*/ SYS_OTA_DOWNLOAD_SUCCESS /*download failed*/ SYS_OTA_DOWNLOAD_FAILED /*image digest verify start*/ SYS_OTA_IMAGE_DIGEST_VERIFY_START /*image digest verify success*/ SYS_OTA_IMAGE_DIGEST_VERIFY_SUCCESS /*image digest verify failed*/ SYS_OTA_IMAGE_DIGEST_VERIFY_FAILED /*patch image digest verify start*/ SYS_OTA_PATCH_IMAGE_DIGEST_VERIFY_START /*patch image digest verify success*/ SYS_OTA_PATCH_IMAGE_DIGEST_VERIFY_SUCCESS /*patch image digest verify failed*/ SYS_OTA_PATCH_IMAGE_DIGEST_VERIFY_FAILED /*Database entry successful*/ SYS_OTA_DB_ENTRY_SUCCESS /*erasing image failed*/ SYS_OTA_IMAGE_ERASE_FAILED /*erasing image success*/ SYS_OTA_IMAGE_ERASED /*image database full*/ SYS_OTA_IMAGE_DATABASE_FULL /*not a defined(as mentioned above) status*/ SYS_OTA_NONE } SYS_OTA_STATUS; ",
							" Summary provide status of ota system ",
							" Description provide status of ota system ",
							" Remarks ",
							" SYS_OTA_Config Struct ",
							" C typedef struct { /*Auto reset is enabled or not*/ uint8_t autoreset; /*OTA periodic check is enabled or not*/ bool ota_periodic_check; /*OTA auto update is enabled or not*/ bool ota_auto_update; /*periodic check time interval*/ uint32_t periodic_check_interval; /*Application version*/ uint32_t app_version; /*ota server url*/ char *json_url; /*json url while taking input from CLI command*/ char json_url_cli[JSON_URL_MAX_LEN]; } SYS_OTA_Config; ",
							" Summary Used for passing on the configuration related to the OTA service ",
							" Remarks None ",
							" SYS_OTA_DATA Struct ",
							" C typedef struct { /* service current state */ SYS_OTA_STATES state; /*to indicate update check with server is failed*/ bool update_check_failed; /*to mage states required for parsing JSON content */ SYS_OTA_STATES update_check_state; /*to keep track of user configure auto update check interval*/ uint32_t time_interval; /*keep track if device connected to network*/ bool dev_cnctd_to_nw; /*to keep track if OTA process is in progress*/ bool otaFwInProgress; /*to keep track if OTA update check with server is in progress*/ bool otaUpdateCheckInProgress; /*to keep track if erase image is triggered by user and in progress*/ bool otaEraseInProgress; /*to keep track if image download success*/ bool download_success; /*to check if user requested for erase functionality*/ bool erase_request; /*to check if user requested for patch functionality*/ bool patch_request; /*check if json contents are proper and required fields are present */ bool json_content_parse_result; /*to track timer callback*/ volatile bool ota_timer_trigger; /*buffer used for JSON content parsing*/ char json_buf[SYS_OTA_JSON_FILE_MAXSIZE]; /*control interface result*/ SYS_OTA_STATUS ota_srvc_status; } SYS_OTA_DATA; ",
							" Summary system service data ",
							" Description This structure holds the system service's data ",
							" Remarks ",
							" SYS_OTA_CALLBACK Typedef ",
							" C typedef void (*SYS_OTA_CALLBACK)(uint32_t event void * data void *cookie); ",
							" SYS_OTA_Initialize Function ",
							" C SYS_OTA_Initialize(void) ",
							" Summary Initializes the System OTA module ",
							" Description This function is used for initializing the data structures of the OTA service OTA service supports only one instance of client ",
							" Parameters None ",
							" Returns None ",
							" Example ",
							" Remarks This routine can only be called once during system initialization If the OTA system service is enabled using MHC then auto generated code will take care of system OTA initialization ",
							" SYS_OTA_CtrlMsg Function ",
							" C SYS_OTA_RESULT SYS_OTA_CtrlMsg(uint32_t event void *buffer uint32_t length); ",
							" Summary Returns success/ failure for the update check/ota trigger/system reset operations asked by client ",
							" Description This function is used to set OTA server and image related parameters ",
							" Precondition The SYS_OTA_Initialize function should have been called before calling this function ",
							" Parameters Param Description url pointer to server version version number of image present in OTA server digest SHA256 key of OTA image ",
							" Returns None ",
							" Example if(ota_app_reg_cb() == true) { uint32_t version = 2; char *digest = \"ef90bf8bf7fd96205c3240c31e1a378430e7a8f053a300e5c91ebe64fefea197\"; SYS_OTA_SET_PARAMETERS(\"http://192 168 43 173:8000/wifi_ota_demo bin\" version digest); appData state = APP_STATE_SERVICE_TASKS; } ",
							" Remarks None ",
							" SYS_OTA_Tasks Function ",
							" C void SYS_OTA_Tasks( void ) ",
							" Summary Maintains the OTA System tasks and functionalities ",
							" Description This function is used to run the various tasks and functionalities of OTA system service ",
							" Precondition The SYS_OTA_Initialize function should have been called before calling this function ",
							" Parameters None ",
							" Returns None ",
							" Example while(1) { SYS_OTA_Task(); } ",
							" Remarks If the OTA system service is enabled using MHC then auto generated code will take care of system task execution ",
							" Registering call back function ",
							" C bool ota_app_reg_cb(void) ",
							" Summary Registering OTA service callback function ",
							" Description This function can be used for easy registering of user callback function It can be called from application layer The definition of the callback function is already present in app_ota c file ",
							" Parameters None ",
							" Returns true - if callback registered successfully false - if callback registration failed ",
							" Example ",
							" Remarks This function definition is present in \"app_ota c\" file Initialization must be done before calling this function ",
							" OTA System Service Developer's Guide ",
							" OTA Service Architecture Overview Over the Air (OTA) firmware upgrade feature is designed with a two step process Image Downloading and Image Programming process Image Downloading is processed by the OTA service that is integrated with your application code Image Programming is processed by the OTA bootloader For detailed information about OTA service architecture please refer to the Architecture Overview section in Using the library of the OTA documentation ",
							" Code modification/implementation guide for common use cases ",
							" Registering a user defined callback for OTA system service Developer may register a callback function to receive callback from the OTA system service for pre-defined scenarios For registering callback developer may follow any one of below mentioned methods a Using the built-in function ota_app_reg_cb() wrapper defined in app_ota c Please see the code snippet below for reference: /* Check the application's current state */ switch ( appData state ) { /* Application's initial state */ case APP_STATE_INIT: { if(true == ota_app_reg_cb()) appData state = APP_STATE_SERVICE_TASKS; appData state = APP_STATE_SERVICE_TASKS; break; } case APP_STATE_SERVICE_TASKS: { break; } /* TODO: implement your application state machine */ default: { /* TODO: Handle error in application's state machine */ break; } } The template of a callback handler function sys_ota_cb() is implemented in app_ota c with all the potential events from the OTA system service Developer can modify this template to build their own custom logic as per system/application requirements void sys_ota_cb(uint32_t event void * data void *cookie) { switch (event) { case SYS_OTA_UPDATE_CHECK_START: { /*OTA update check start Customer can build their own custom logic */ SYS_CONSOLE_PRINT(\"SYS_OTA_UPDATE_CHECK_START r n\"); break; } case SYS_OTA_UPDATE_CHECK_FAILED: { /*OTA update check failed Customer can build their own custom logic */ SYS_CONSOLE_PRINT(\"SYS_OTA_UPDATE_CHECK_FAILED r n\"); break; } case SYS_OTA_UPDATE_AVAILABLE: { /*OTA update available Customer can build their own custom logic */ SYS_CONSOLE_PRINT(\"SYS_OTA_UPDATE_AVAILABLE r n\"); break; } case SYS_OTA_UPDATE_NOTAVAILABLE: { /*OTA update not available Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_UPDATE_NOTAVAILABLE r n\"); break; } case SYS_OTA_TRIGGER_OTA_FAILED: { /*OTA trigger failed Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_TRIGGER_OTA_FAILED r n\"); break; } case SYS_OTA_FACTORY_RESET_SUCCESS: { /*OTA Factory reset success Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_FACTORY_RESET_SUCCESS r n\"); break; } case SYS_OTA_FACTORY_RESET_FAILED: { /*OTA Factory reset failed Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_FACTORY_RESET_FAILED r n\"); break; } case SYS_OTA_ROLLBACK_SUCCESS: { /*OTA rollback success Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_ROLLBACK_SUCCESS r n\"); break; } case SYS_OTA_ROLLBACK_FAILED: { /*OTA rollback failed Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_ROLLBACK_FAILED r n\"); break; } case SYS_OTA_DOWNLOAD_START: { /*OTA image download start Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_DOWNLOAD_START r n\"); break; } case SYS_OTA_DOWNLOAD_SUCCESS: { /*OTA image download success Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_DOWNLOAD_SUCCESS r n\"); break; } case SYS_OTA_DOWNLOAD_FAILED: { /*OTA image download failed Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_DOWNLOAD_FAILED r n\"); break; } case SYS_OTA_IMAGE_DIGEST_VERIFY_START: { /*OTA image digest verify start Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_IMAGE_DIGEST_VERIFY_START r n\"); break; } case SYS_OTA_IMAGE_DIGEST_VERIFY_SUCCESS: { /*OTA image digest verify success Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_IMAGE_DIGEST_VERIFY_SUCCESS r n\"); break; } case SYS_OTA_IMAGE_DIGEST_VERIFY_FAILED: { /*OTA image digest verify failed Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_IMAGE_VERIFICATION_FAILED r n\"); break; } case SYS_OTA_DB_ENTRY_SUCCESS: { /*OTA database entry successful Customer can build their own custom logic*/ /*For Manual reset user must trigger system reset after system reach this state only*/ /*Do not use API call from here Use variables to get the status*/ SYS_CONSOLE_PRINT(\"SYS_OTA_DB_ENTRY_SUCCESS r n\"); ota_complete = true; break; } case SYS_OTA_IMAGE_ERASE_FAILED: { /*OTA image erase failed Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_IMAGE_ERASE_FAILED r n\"); break; } case SYS_OTA_IMAGE_ERASED: { /*OTA image erase success Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_IMAGE_ERASED r n\"); break; } case SYS_OTA_IMAGE_DATABASE_FULL: { /*OTA image database full Customer can build their own custom logic*/ SYS_CONSOLE_PRINT(\"SYS_OTA_IMAGE_DATABASE_FULL r n\"); break; } default: { /*unknown state*/ break; } } b Alternately developers may use SYS_OTA_CtrlMsg() API to register their own callback function Please follow below code snippet for reference : if (SYS_OTA_SUCCESS == SYS_OTA_CtrlMsg(SYS_OTA_REGCALLBACK sys_ota_cb sizeof (uint8_t *))) { /*Callback register request success*/ } else { /*Callback register request fail*/ } ",
							" Check for updates on a custom trigger trigger : Your system design may have requirements to check update image availability in OTA server only during specific particular conditions (e g : Switch pressed or when a MQTT message received on a specific topic) System should then initiate an OTA check in the image server Under such condition to initiate update check on user trigger user may follow below steps: 1 Disable Periodic OTA check option in MHC configuration resized_disable_periodic_ota 2 Generate code 3 Modify application code to initiate update check using control API SYS_OTA_CtrlMsg(uint32_t event void *buffer uint32_t length) when trigger condition is fulfilled (e g when a switch is pressed ) ```c if(SWITCH1_Get() == SWITCH1_STATE_PRESSED ) { SYS_OTA_CtrlMsg(SYS_OTA_UPDATECHCK NULL NULL); } ``` ",
							" Initiate OTA on user trigger : System design may have requirements to trigger an OTA update only once a condition only is met (e g : Switch pressed or when a MQTT message received from MQTT server) Under such condition to trigger OTA manually user may follow below steps: 1 Disable Auto OTA update and Periodic OTA check options in MHC configuration manual_trigger_disable_mhc_option 2 Generate code 3 Developer should provide server URL OTA image version number present in OTA server and digest of OTA image using API SYS_OTA_SET_PARAMETERS(char *url uint8_t version char *digest) 1 The parameters should be sent to the device out of band E g: The payload of an MQTT message 2 It would be user responsibility to provide correct image version number as OTA service will not be doing any verion check of ota image It will simply download the image from user defined server and store the parameter details as provided into OTA database 4 Modify application code to trigger OTA using control API SYS_OTA_CtrlMsg(uint32_t event void *buffer uint32_t length) when trigger condition is fulfilled (e g when a switch is pressed ) ```c /* Check the application's current state */ switch ( appData state ) { /* Application's initial state */ case APP_STATE_INIT: { if(ota_app_reg_cb() == true) { uint8_t version = 2; char *digest = \"ef90bf8bf7fd96205c3240c31e1a378430e7a8f053a300e5c91ebe64fefea197\"; SYS_OTA_SET_PARAMETERS(\"http://192 168 43 173:8000/wifi_ota_demo bin\" version digest); appData state = APP_STATE_SERVICE_TASKS; } break; } case APP_STATE_SERVICE_TASKS: { if((SWITCH1_Get() == SWITCH1_STATE_PRESSED) (ota_initiated == false)) { ota_initiated = true; if(SYS_OTA_SUCCESS == SYS_OTA_CtrlMsg(SYS_OTA_INITIATE_OTA NULL NULL)) appData state = APP_STATE_OTA_INITIATE_SUCCESS; else ota_initiated = false; } break; } case APP_STATE_OTA_INITIATE_SUCCESS: { break; } /* TODO: implement your application state machine */ default: { /* TODO: Handle error in application's state machine */ break; } } ### **Initiate Factory Reset on user trigger :** Factory Reset is a functionality using which user may get the system back to its original state meaning the Factory image will be programmed to internal flash (Program memory) and all other OTA images will be erased from external flash storage along with OTA database if it exist User may initiate Factory reset using the `SYS_OTA_TRIGGER_FACTORY_RESET` control message as shown in the code snippet below ```c if(SWITCH1_Get() == SWITCH1_STATE_PRESSED ) { SYS_OTA_CtrlMsg(SYS_OTA_TRIGGER_FACTORY_RESET NULL NULL); } ",
							" How to trigger system reset (from application) on successful OTA completion with Autoreset option disabled in MHC : Developer may choose to disable Autoreset option in MHC and may have requirement to build custom logic for application deciding when to go for system reset after successful OTA download This will enable the system/application to complete important tasks before triggering a system reset Developer may easily develop such custom logic using SYS_OTA_CtrlMsg() API for system reset Please follow below code snippet for reference : if (SYS_OTA_SUCCESS == SYS_OTA_CtrlMsg(SYS_OTA_TRIGGER_SYSTEM_RESET NULL NULL)) { /*System reset request success */ } else { /*System reset request fail*/ } Please note that SYS_OTA_CtrlMsg() will return SYS_OTA_SUCCESS if the request is successful System will reset only if OTA download has completed successfully User can check for SYS_OTA_DB_ENTRY_SUCCESS system callback state to trigger manual reset ",
							" How to limit periodic OTA check for a definite number of times : Developer may have requirement to limit periodic OTA check to a definite number of times For example OTA service should go to idle state until next reset after checking update availability for 3 times consecutively For this developer may add below lines of code in sys_ota c file: if(update_check_counter++ = 3) // `update_check_counter` is an extern variable defined by developer { SYS_CONSOLE_PRINT(\"Update availability check completed for 3 times no update found n r\"); sys_otaData state = SYS_OTA_IDLE; break; } resized_limit_periodic_check ",
							" What will happen if an image is downloaded successfully but image digest verify fails : With default logic the downloaded image will be erased if digest verify fails OTA system service will disable auto update check provide user callback and go to IDLE mode ",
							" How developer can trigger periodic update check when a user defined condition is satisfied (e g : switch pressed) : Developer may have the requirement to trigger periodic update check only when a user defined condition is satisfied Let us assume a scenario in which application should trigger periodic update check when user press a switch To develop this particular requirement user may follow below steps : 1 Disable Periodic OTA Check option in MHC disable_periodic_check 2 Generate code using MHC 3 Add below lines of code at the beginning of case SYS_OTA_SERVER_UPDATE_CHECK in sys_ota c file g_SysOtaConfig ota_periodic_check = true; sys_otaData state = SYS_OTA_AUTO_CONFIGURATION_CHECK; break; periodic_check_on_user_trigger 4 Write custom logic in application file \"app c\" if((SWITCH1_Get() == SWITCH1_STATE_PRESSED) (ota_initiated == false)) { ota_initiated = true; if(SYS_OTA_SUCCESS == SYS_OTA_CtrlMsg(SYS_OTA_UPDATECHCK NULL 0)) appData state = APP_STATE_OTA_INITIATE_SUCCESS; else ota_initiated = false; } ",
							" How to get download status during OTA update : Application Developer may want to get the download status during OTA update for certain application logic development They may easily extract download status using below lines of code : { OTA_GetDownloadStatus( ota_params);//ota_params should be defined as : OTA_PARAMS ota_params; SYS_CONSOLE_PRINT(\"******************************************* n r\"); SYS_CONSOLE_PRINT(\"Total data to download : %d bytes n r\" ota_params server_image_length); SYS_CONSOLE_PRINT(\"Data downloaded : %d bytes r n\" ota_params total_data_downloaded); SYS_CONSOLE_PRINT(\"******************************************* n r\"); } ",
							" Web Socket Server (WSS) System Service Web Socket Server System Service Library provides an application programming interface (API) for implementing a Web Socket Server functionalities as defined in rfc6455 The WSS System Service uses the underlying net system service APIs for TCP/IP and network functionalities Key Features: Implements the WSS protocol as a service Supports multiple client connections simultaneously The WSS System Service provides simple API's MHC configurations and application templates for handling various WSS events ",
							" Web Socket Server System Service Usage ",
							" Description Web Socket Server System Service Library provides an application programming interface (API) for implementing a Web Socket Server functionalities The user need not take care about the frame connection handshakes the data frame formatting etc The WSS System Service uses the underlying Net system Service APIs for achieving TCPIP network functionalities ",
							" Abstraction Model The Web Socket Server System Service provides an abstraction to the complete Web Socket Server implementation with the following functinalities Connectivity to multiple clients Simple APIs for data exchanges Reduced time for application development The following diagram depicts the Web Socket Server System Service abstraction model AbstractionModel_WSS ",
							" How the service works Once the user configures the Web Socket Server System Service in the MHC the MHC will generate the required code for service implementation User need to implement his application according to the requirement The WSS system service initialization will be taken care with the code generation To get the indication on Web Socket Server events use need to register the callback function using the API SYS_WSS_register_callback() ",
							" Web Socket Server System Service Initialization Initialization_WSS ",
							" Web Socket Server System Service API usage The below diagram shows the API usage of the Web Socket Server System service APIusage_greyScale2 ",
							" Web Socket Server (WSS) System Service Configuration The WSS System Service library should be configured through MHC When user adds the WSS System Service into a project all the required dependencies and components are added automatically into the the projects MHC configuration The user can make changes according to the application requirement in the WSS System Service configuration menu The following figure shows the MHC configuration window for configuring the WSS System Service and a brief description of various configuration options 1 Open the MHC 3 2 Drag the WSS Service Module into from the Available components into the Project Graph This will trigger the auto activation of the dependent modules Click on 'Yes' in the confirmation window popped up for component auto activation resized_Activate_WSS 3 Configure the various parameters resized_ConfigWSS Parameter Description Port port used by the WSS service Default is 8000 Debug Control debug prints Disabled by default Secure Socket Enable/Disable secure web socket Make sure that you configure the required server certificate and keys in the underlying layers Application template Generation Control the generation of an application template with all the available callbacks ConfWSS_PortDebugTLSAppTemplate 4 Enabling secure websocket To enable the secure web socket support user need to enable the below configuration options 1 Enable the highlighted option in the Web Socket Server Service MHC configuration wss_tls_enable 2 Enable the highlighted options in the Presentation layer net_pres component The server certificate used by default will be the one provided by the wolfssl module The user need to provide the required modifications in the highlighted parameters incase of application specific certificate and keys wss_tls_netpress 5 Advanced Configuration with RX buffer size maximum number of supported clients client timeout and start at boot features Parameter Description Max Rx buffer length Max length of the buffer used to receive and process messages Default is 1400 Max number of clients Max number of clients allowed to connect to teh WSS Default is 2 Client timeout in ms Timeout after which the client is disconnected in case of no data transfer or ping after connection Default is 30000 Start at boot Control when the WSS is enabled Enabled at boot by default AdvancedConf_WSS 6 FreeRTOS configuration enabled by default Parameter Description RTOS Task Delay(ms) WSS RTOS task delay Default is 1 ms RTOS Task Stack Size WSS RTOS task stack size Default is 4096 RTOS Task priority WSS RTOS task priority Default is 1 All of the required files are automatically genarted and added into the MPLAB X IDE project by the MHC when the code generation completes successfully ",
							" Web Socket Server System Service Interface ",
							" Data Types and Constants Summary Name Description SYS_WSS_KA_TIMER_PERIOD Decides the accuracy of the client timeout SYS_WSS_CLIENT_KEY_SIZE Array size for holding the client key SYS_WSS_CLIENT_KEY_SIZE_DECODED Decoded client key size as per the RFC6455 SYS_WSS_SERVER_KEY_SIZE Array saze for holding the server key SYS_WSS_SHA1_DIGEST_SIZE SHA1 digest size -server key genartion SYS_WSS_HTTP_VERSION_0_9 HTTP vesrion 0 9 SYS_WSS_HTTP_VERSION_1_0 HTTP version 1 0 SYS_WSS_HTTP_VERSION_1_1 HTTP version 1 1 SYS_WSS_STATUS_CODE_LEN Closing Status code lenth as per RFC6455 SYS_WSS_GUID WebSocket GUID as per Section 1 3 of RFC 6455 SYS_WSS_CONFIG Used for passing on the configuration(port and TLS) for socket connection SYS_WSS_HANDSHAKE_CTXT Stores the handshake information of a client SYS_WSS_FRAME_HEADER Identifies the frame format as defined by RFC6455 SYS_WSS_RXDATA Stores the data received from the client along with the datalength SYS_WSS_RESULT Identifies the return values for the WSS system service APIs SYS_WSS_STATE Identifies the state machine values of the WSS system service SYS_WSS_FRAME Identifies the frame types as defined by the RFC6455 SYS_WSS_EVENTS Identifies the events reported to the application using the call back function SYS_WSS_STATUS_CODE Identifies status code to be used in the closing handshake as defined by RF6455 ",
							" Initialization functions Summary Name Description SYS_WSS_Initialize Returns wss object handle after initialization of data structures and timers of the WSS system service SYS_WSS_Deinitialize Deinitialization of data structures of the WSS system service ",
							" Data Exchange functions Summary Name Description SYS_WSS_sendMessage Returns failure or success after sending the data to the client SYS_WSS_register_callback Returns success after registration of the user call back function SYS_WSS_CloseConnection Returns success after sending a close frame to the client SYS_WSS_PingClient Returns success after sending a ping frame to the client ",
							" SYS_WSS_GUID Macro ",
							" C #define SYS_WSS_GUID \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\" ",
							" Summary The unique ID for generating the sever acceptance key defined by the RFC 6455 ",
							" Remarks WebSocket GUID as per Section 1 3 of RFC 6455 ",
							" SYS_WSS_CLIENT_KEY_SIZE Macro ",
							" C #define SYS_WSS_CLIENT_KEY_SIZE 50 ",
							" Summary Array size for holding the client key ",
							" Remarks None ",
							" SYS_WSS_CLIENT_KEY_SIZE_DECODED Macro ",
							" C #define SYS_WSS_CLIENT_KEY_SIZE_DECODED 16 ",
							" Summary The size of the decoded client key defined by the RFC 6455 ",
							" Remarks None ",
							" SYS_WSS_HTTP_VERSION_1_1 Macro ",
							" C #define SYS_WSS_HTTP_VERSION_1_1 0x0101 ",
							" Summary Supported HTTP versions ",
							" Remarks None ",
							" SYS_WSS_KA_TIMER_PERIOD Macro ",
							" C #define SYS_WSS_KA_TIMER_PERIOD 100 ",
							" Summary Set to 100 ",
							" Remarks This parameter will decide the accuracy of the client time out ",
							" SYS_WSS_SERVER_KEY_SIZE Macro ",
							" C #define SYS_WSS_SERVER_KEY_SIZE 50 ",
							" Summary Array size for holding the server key ",
							" Remarks None ",
							" SYS_WSS_SHA1_DIGEST_SIZE Macro ",
							" C #define SYS_WSS_SHA1_DIGEST_SIZE 20 ",
							" Summary The predefined sha digest size ",
							" Remarks None ",
							" SYS_WSS_STATUS_CODE_LEN Macro ",
							" C #define SYS_WSS_STATUS_CODE_LEN 2 ",
							" Summary The size of the status code to be returned in a closing handshake defined by the RFC 6455 ",
							" Remarks None ",
							" SYS_WSS_RESULT Enum ",
							" C typedef enum { SYS_WSS_SUCCESS = 0 //successful execution SYS_WSS_FAILURE = 1 //Failure in execution SYS_WSS_ERROR_INVALID_REQUEST //Failure in validation of the client handshake SYS_WSS_ERROR_INVALID_KEY //Failure in validation of the client handshake SYS_WSS_ERROR_INVALID_FRAME //Failure in validation of the client request } SYS_WSS_RESULT; ",
							" Summary Reporting the success/failure of an API execution ",
							" Remarks None ",
							" SYS_WSS_EVENTS Enum ",
							" C typedef enum { SYS_WSS_EVENT_ERR=0 //Reports any error condition //SYS_WSS_EVENT_UP SYS_WSS_EVENT_CLIENT_CONNECTING //Reports the connection request from the client SYS_WSS_EVENT_CLIENT_CONNECTED //Reports connection completed status SYS_WSS_EVENT_CLIENT_BIN_DATA_RX //Reports the reception of a binary data SYS_WSS_EVENT_CLIENT_TXT_DATA_RX //Reports the reception of a text data SYS_WSS_EVENT_CLIENT_PING_RX //Report the reception of a ping message SYS_WSS_EVENT_CLIENT_PONG_RX //Reports the reception of a pong message SYS_WSS_EVENT_CLIENT_CLOSE_FRAME_RX //Reports the reception of a closing handshake SYS_WSS_EVENT_CLIENT_CLOSING //Reports the connection closing SYS_WSS_EVENT_CLIENT_CLOSED //Reports the connection closure completion SYS_WSS_EVENT_ERR_INVALID_FRAME //Reports the reception of an invalid frame // SYS_WSS_EVENT_DOWN SYS_WSS_EVENT_CLIENT_TIMEOUT //Reports the client connection timeout } SYS_WSS_EVENTS; ",
							" Summary The event to be reported to the application from the WSS service according to the message exchanges with the client ",
							" Remarks None ",
							" SYS_WSS_STATE Enum ",
							" C typedef enum { SYS_WSS_STATE_CLOSED=0 //Connection closed the initial state of the service SYS_WSS_STATE_CLOSING //Handles the processing of the client closing handshake SYS_WSS_STATE_CONNECTING //Handles the processing of the client opening handshake SYS_WSS_STATE_CONNECTED //State where the data exchanges happen } SYS_WSS_STATE; ",
							" Summary States for handling the various requirements of the Web Socket Server implementation like opening handshake ping-pong data messages closing handshakes etc ",
							" Remarks None ",
							" SYS_WSS_FRAME Enum ",
							" C typedef enum { SYS_WSS_FRAME_CONTINUATION = 0x00 //Continuation frame - Data frame with opcode 0 SYS_WSS_FRAME_TEXT = 0x01 //Text data frame - Data frame with opcode 1 SYS_WSS_FRAME_BINARY = 0x02 //Binary data frame - Data frame with opcode 2 SYS_WSS_FRAME_CLOSE = 0x08 //Connection close frame - Control frame with opcode 8 SYS_WSS_FRAME_PING = 0x09 //Ping frame - Ping frame with opcode 9 SYS_WSS_FRAME_PONG = 0x0A //Pong frame - Pong frame with opcode 10 } SYS_WSS_FRAME; ",
							" Summary The supported frames (control and data) as defined in RFC 6455 Section 5 ",
							" Remarks None ",
							" SYS_WSS_STATUS_CODE Enum ",
							" C typedef enum { SYS_WSS_STATUS_CODE_NORMAL_CLOSURE = 1000 SYS_WSS_STATUS_CODE_GOING_AWAY = 1001 SYS_WSS_STATUS_CODE_PROTOCOL_ERROR = 1002 SYS_WSS_STATUS_CODE_UNSUPPORTED_DATA = 1003 SYS_WSS_STATUS_CODE_NO_STATUS_RCVD = 1005 //reserved code Not to be used in the close frames SYS_WSS_STATUS_CODE_ABNORMAL_CLOSURE = 1006 //reserved Not to be used in the close frames SYS_WSS_STATUS_CODE_INVALID_PAYLOAD_DATA = 1007 SYS_WSS_STATUS_CODE_POLICY_VIOLATION = 1008 SYS_WSS_STATUS_CODE_MESSAGE_TOO_BIG = 1009 SYS_WSS_STATUS_CODE_MANDATORY_EXT = 1010 SYS_WSS_STATUS_CODE_INTERNAL_ERROR = 1011 SYS_WSS_STATUS_CODE_TLS_HANDSHAKE = 1015 // reserved code Not to be used in the close frames } SYS_WSS_STATUS_CODE; ",
							" Summary The status codes to be reported to the clients as per RFC6455 11 7 ",
							" Remarks None ",
							" SYS_WSS_HANDSHAKE_CTXT Struct ",
							" C typedef struct { uint16_t http_version; //HTTP version specified in the client handshake uint8_t ws_version; //Web socket version specified in the client handshake bool upgradeWebSocket; //If upgrade websocket field specified in the client handshake bool origin; //If origin field specified in the client handshake bool connectionUpgrade; //If upgrade field present in the client handshake bool iskey; //If websocket key is present in the client handshake char clientKey[SYS_WSS_CLIENT_KEY_SIZE + 1]; //Client key char serverKey[SYS_WSS_SERVER_KEY_SIZE + 1]; // Server key } SYS_WSS_HANDSHAKE_CTXT; ",
							" Summary Used for the storing the information related to the opening handshake ",
							" Remarks None ",
							" SYS_WSS_RXDATA Struct ",
							" C typedef struct { uint8_t * data; //Pointer to the rx data buffer int64_t datalen; //length of the received data } SYS_WSS_RXDATA; ",
							" Summary The RX data structure used for sharing the received data and length to the application ",
							" Remarks None ",
							" SYS_WSS_CONFIG Struct ",
							" C typedef struct { unsigned int port; //port used by the WSS service bool isTLSEnabled; //TLS enabled } SYS_WSS_CONFIG; ",
							" Summary Used for the providing the port and secure connection information during WSS service initialization SYS_MODULE_OBJ SYS_WSS_Initialize(SYS_WSS_CONFIG *config SYS_WSS_CALLBACK callback void *cookie) ",
							" Remarks None ",
							" SYS_WSS_CALLBACK Typedef ",
							" C typedef void (*SYS_WSS_CALLBACK)(SYS_WSS_EVENTS event void *data int32_t clientIndex void *cookie); ",
							" SYS_WSS_Initialize Function ",
							" C SYS_MODULE_OBJ SYS_WSS_Initialize() ",
							" Summary Returns SYS_MODULE_OBJ after the successful initialization of data structures of the WSS service ",
							" Description This function is used for initializing the data structures of the WSS service and is called from within the System Task This function also can be called by the application with required arguments ",
							" Returns Returns the address of an array of SYS_MODULE_OBJ which will have the initialization data for all clients ",
							" Example sysWSS_obj = SYS_WSS_Initialize(NULL NULL NULL); //Default config callback and cookie will be taken ",
							" Remarks If the Web Socket Server system service is enabled using MHC then auto generated code will take care of initialization ",
							" SYS_WSS_Deinitialize Function ",
							" C void SYS_WSS_Deinitialize() ",
							" Summary When invoked the API will de-initialize the WSS service ",
							" Description This function is used for de-initializing the data structures and state machine of the WSS service This function can be called by the application with WSS service object handle ",
							" Returns None ",
							" Example * SYS_WSS_Deinitialize( sysWSSObj); ",
							" Remarks None ",
							" SYS_WSS_PingClient Function ",
							" C SYS_WSS_RESULT SYS_WSS_PingClient( uint8_t *data size_t dataLen int32_t clientIndex) ",
							" Summary Sends a ping message to the client indicated by the parameter clientIndex ",
							" Description This API sends a ping message to the client indicated by the parameter clientIndex ",
							" Precondition The connection state of the client indicated by the clientIndex (g_wssSrvcObj wssState) shall be SYS_WSS_STATE_CONNECTED ",
							" Parameters Param Description *data A pointer to buffer with the data (if any) dataLen Length of the data clientIndex The clientID for identifying the client which caused the event to occur ",
							" Returns SYS_WSS_RESULT ",
							" Example SYS_WSS_RESULT res; res =SYS_WSS_PingClient( data dataLen 1); ",
							" Remarks None ",
							" SYS_WSS_register_callback Function ",
							" C SYS_WSS_RESULT SYS_WSS_register_callback(SYS_WSS_CALLBACK userCallback void* cookie) ",
							" Summary API for registering the application callback function with the WSS service ",
							" Description Callback functions may be registered by clients of the WSS service during the initialization using this API ",
							" Precondition None ",
							" Parameters Param Description userCallback A function pointer to the application call back API event Data (if any) related to the Event cookie A context value returned untouched to the client when the callback occurs ",
							" Returns SYS_WSS_RESULT ",
							" Example void wss_user_callback(SYS_WSS_EVENTS event void *data int32_t clientIndex void *cookie) { int i = 0; switch (event) { case SYS_WSS_EVENT_CLIENT_CONNECTING: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_CONNECTING r n\" clientIndex); break; } case SYS_WSS_EVENT_CLIENT_CONNECTED: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_CONNECTED r n\" clientIndex); break; } case SYS_WSS_EVENT_CLIENT_BIN_DATA_RX: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_BIN_DATA_RX r n\" clientIndex); for (i = 0; i ((SYS_WSS_RXDATA*) data)- datalen; i++) { SYS_CONSOLE_PRINT(\"%X \" ((SYS_WSS_RXDATA*) data)- data[i]); } SYS_CONSOLE_PRINT(\" r n\"); //echo server SYS_WSS_sendMessage(1 SYS_WSS_FRAME_TEXT ((SYS_WSS_RXDATA*) data)- data ((SYS_WSS_RXDATA *) data)- datalen clientIndex); break; } case SYS_WSS_EVENT_CLIENT_TXT_DATA_RX: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_TXT_DATA_RX r n\" clientIndex); for (i = 0; i ((SYS_WSS_RXDATA *) data)- datalen; i++) { SYS_CONSOLE_PRINT(\"%c\" ((SYS_WSS_RXDATA*) data)- data[i]); } SYS_CONSOLE_PRINT(\" r n\"); // Enable the below statement for echo server //SYS_WSS_sendMessage(1 SYS_WSS_FRAME_TEXT ((SYS_WSS_RXDATA*) data)- data ((SYS_WSS_RXDATA *) data)- datalen clientIndex); break; } case SYS_WSS_EVENT_CLIENT_CLOSING: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_CLOSING r n\" clientIndex); break; } case SYS_WSS_EVENT_CLIENT_CLOSED: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_CLOSED r n\" clientIndex); break; } case SYS_WSS_EVENT_ERR_INVALID_FRAME: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_ERR_INVALID_FRAME r n\" clientIndex); break; } case SYS_WSS_EVENT_CLIENT_PING_RX: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_PING_RX r n\" clientIndex); break; } case SYS_WSS_EVENT_CLIENT_PONG_RX: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_PONG_RX r n\" clientIndex); break; } case SYS_WSS_EVENT_CLIENT_CLOSE_FRAME_RX: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_CLOSE_FRAME_RX r n\" clientIndex); break; } case SYS_WSS_EVENT_ERR: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_ERR r n\" clientIndex); break; } case SYS_WSS_EVENT_DOWN: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_DOWN r n\" clientIndex); break; } case SYS_WSS_EVENT_CLIENT_TIMEOUT: { SYS_CONSOLE_PRINT(\"wssSysServCallback(%d): SYS_WSS_EVENT_CLIENT_TIMEOUT r n\" clientIndex); break; } } } ",
							" Remarks None ",
							" SYS_WSS_sendMessage Function ",
							" C SYS_WSS_RESULT SYS_WSS_sendMessage(bool fin SYS_WSS_FRAME type uint8_t *data size_t dataLen int32_t clientIndex) ",
							" Summary Sends a message to the client indicated by the parameter clientIndex ",
							" Description This API sends the data provided in the web socket frame format to the client indicated by the parameter clientIndex ",
							" Precondition The connection state of the client indicated by the clientIndex (g_wssSrvcObj wssState) shall be SYS_WSS_STATE_CONNECTED ",
							" Parameters Param Description fin Fin value as defined by RFC6455 to indicate if the frame is final or continuation frame 0 = Indicates more messages to follow the current frame is a continuation frame 1 = Indicates the final frame of the message type The data type of the frame TEXT or BINARY *data A pointer to buffer with the data to be sent dataLen Length of the data clientIndex The clientID for identifying the client which caused the event to occur ",
							" Returns SYS_WSS_RESULT ",
							" Example SYS_WSS_RESULT res; res = SYS_WSS_sendMessage(1 SYS_WSS_FRAME_TEXT ((SYS_WSS_RXDATA*) data)- data ((SYS_WSS_RXDATA *) data)- datalen clientIndex); ",
							" Remarks None ",
							" SYS_WSS_CloseConnection Function ",
							" C SYS_WSS_RESULT SYS_WSS_CloseConnection(SYS_WSS_STATUS_CODE code uint8_t *data size_t dataLen int32_t clientIndex) ",
							" Summary Closes the Web Socket connection to the client indicated by the parameter clientIndex ",
							" Description This API initiate the closing handshake with the status code provided and and terminate the Web Socket connection to the client indicated by the parameter clientIndex ",
							" Precondition The connection state of the client indicated by the clientIndex (g_wssSrvcObj wssState) shall be SYS_WSS_STATE_CONNECTED ",
							" Parameters Param Description code Status code to be send to the client in the closing handshake(SYS_WSS_STATUS_CODE) *data A pointer to buffer with the data (if any) related to the connection closure dataLen Length of the data clientIndex The clientID for identifying the client which caused the event to occur ",
							" Returns SYS_WSS_RESULT ",
							" Example SYS_WSS_RESULT res; res =SYS_WSS_CloseConnection(SYS_WSS_STATUS_CODE_UNSUPPORTED_DATA NULL 0 1); ",
							" Remarks None ",
							" SYS_WSS_Task Function ",
							" C void SYS_WSS_Task(SYS_MODULE_OBJ obj) ",
							" Summary Executes the SYS NET service and handles the WSS service timer processing ",
							" Description ",
							" Precondition SYS_WSS_Initialize() should have been called before calling this function ",
							" Parameters Application can pass NULL as argument The service will internally take care about the network handles ",
							" Returns Always returns 0 ",
							" Example while(1) { SYS_WSS_Task(NULL); } ",
							" Web Socket Server System Service Developer's Guide The purpose of this document is to explain the Web Socket Server system service design to enable the developer to make changes in the service code as per his/ her requirements if the need be ",
							" Overview The WSS system service provides an application programming interface (API) to manage the Web Socket Server functionalities over TCP/IP Networking The WSS system service uses the MPLAB Harmony NET system service to achieve the TCPIP functionalities Key Features: Implements the WSS protocol as a service Supports multiple client connections simultaneously AbstractionModel_WSS ",
							" Detailed Design WSS system service is a background service with which the application can interact using the APIs provided The idea of the WSS system service is to reduce the code size for the application and simplifying the state machine that the application may need to maintain by abstracting out the complexity of the Web Socket Server in the system service ",
							" State Machine The various states of the WSS system service are of the enum type SYS_WSS_STATE  The WSS system service runs a finite state machine with the following states: SYS_WSS_STATE_CLOSED : Initial State of the WSS system service at the initialization SYS_WSS_STATE_CLOSING : An intermediate state which handles the processing of the client closing handshake SYS_WSS_STATE_CONNECTING : An intermediate state which handles the processing of the client opening handshake SYS_WSS_STATE_CONNECTED : The state which handles all the data transmissions StateMachine ",
							" Number of Clients Supported The maximum number of Clients supported by WSS system service currently is 8 The user can change the value via the MHC Default the value is set to 2 ",
							" Client time out The user can configure a timeout value which will be considered as a maximum idle time for a client connection The default timeout value is 30s ",
							" API Implementation This section describes the high level implementation details of the WSS APIs ",
							" SYS_WSS_register_callback() The API is used for registering the application callback function with the WSS service SYS_WSS_register_callback ",
							" SYS_WSS_CloseConnection() This API is used to close the Web Socket connection to the client indicated by the parameter clientIndex This will initiate the closing handshake from the server SYS_WSS_CloseConnection ",
							" SYS_WSS_PingClient() This API is used to send a ping message to the client indicated by the parameter clientIndex SYS_WSS_PingClient ",
							" SYS_WSS_sendMessage() This API is used to send a message to the client indicated by the parameter clientIndex  SYS_WSS_sendMessage ",
							" SYS_WSS_Initialize() / SYS_WSS_Deinitialize() These functions are used for initializing/ deinitializing the data structures of the WSS system service ",
							" Code location The base code for the WSS system service can be found in the wireless_system_pic32mzw1_wfi32e01 system wss The same shall be copied to the following location after the code for the application is generated – my_application firmware src config pic32mz_w1_curiosity system wss The core includes two files: Header file: sys_wss h Source file: src/sys_wss c The WSS component can also optinoally generate two application template files The template file includes a callback that can be modified as required by the end user application Header file: app_wss h Source file: src/app_wss c Since the above files could see modifications across releases the users should take care of merging the changes they did in these files with the ones which were done in the new release by Microchip Team For this the user needs to take care of this while generating the code via the MHC: MhcMergeStrategy While generating the code the user should use the Merge Strategy as USER_ALL and click Generate In case there are changes done by user in any of the files the MHC shall prompt the user about it: resized_MhcMergeWindow The user can merge his changes with the the latest changes done in the services using the above window "];

